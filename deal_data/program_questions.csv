problem_id,problem_text,skill_name,choiceA,choiceB,choiceC,choiceD,answer,"level(0,1,2)(表示三个难度等级"
1,"搭建JDK和Eclipse环境，完成一个程序编写、运行和调试。
```java
public class HelloWorld {
public static void main(String[] args) {
System.out.println(""Hello World!"");
int a = 1;
a=a+1;
a=a+2;
System.out.println(""a is "" + a);
a=a+3;  //断点行
a=a+4;
System.out.println(""a is "" + a);
}
}
```
(1). 编写以上程序，并运行。
(2). 将断点设置在第八行，查看变量a的值，提交此刻的屏幕截图。",程序编写、编译和运行,,,,,"(1)""Hello World!"", ""a is 4"",""a is 11""
(2)a=7",0
,"# Hello,World!

## 题目描述

编写一个能够输出 `Hello,World!` 的程序。

提示：
- 使用英文标点符号；
- `Hello,World!` 逗号后面**没有**空格。
- `H` 和 `W` 为**大写**字母。

## 输入格式

## 输出格式

## 样例 #1

### 样例输入 #1

```
无
```

### 样例输出 #1

```
Hello,World!
```",顺序结构,,,,,"```java
public class Main {
    public static void main(String[] args) {
        System.out.println(""Hello,World!"");
    }
}
```",0
,"# 输出字符菱形

## 题目描述

用 `*` 构造一个对角线长 $5$ 个字符，倾斜放置的菱形。

## 输入格式

没有输入要求。

## 输出格式

如样例所示。用 `*` 构成的菱形。

## 样例 #1

### 样例输入 #1

```

```

### 样例输出 #1

```
*
 ***
*****
 ***
  *
```",顺序结构,,,,,"```java
public class DiamondPattern {
    public static void main(String[] args) {
        int n = 5; // 对角线长度为5，所以是5行
        int i, j;
        int space = n / 2; // 空格数量

        // 打印上半部分的菱形
        for (j = 1; j <= n; j += 2) {
            // 打印空格
            for (i = 1; i <= space; i++) {
                System.out.print("" "");
            }
            space--;

            // 打印星号
            for (i = 1; i <= j; i++) {
                System.out.print(""*"");
            }
            System.out.println();
        }

        // 重置空格数量为1，以便打印下半部分的菱形
        space = 1;

        // 打印下半部分的菱形
        for (j = n - 2; j >= 1; j -= 2) {
            // 打印空格
            for (i = 1; i <= space; i++) {
                System.out.print("" "");
            }
            space++;

            // 打印星号
            for (i = 1; i <= j; i++) {
                System.out.print(""*"");
            }
            System.out.println();
        }
    }
}

```",1
,"# 超级玛丽游戏

## 题目背景

本题是洛谷的试机题目，可以帮助了解洛谷的使用。

建议完成本题目后继续尝试 [P1001](/problem/P1001)、[P1008](/problem/P1008)。  

另外强烈推荐[新用户必读贴](/discuss/show/241461)

## 题目描述

超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。

```
                ********
               ************
               ####....#.
             #..###.....##....
             ###.......######              ###            ###
                ...........               #...#          #...#
               ##*#######                 #.#.#          #.#.#
            ####*******######             #.#.#          #.#.#
           ...#***.****.*###....          #...#          #...#
           ....**********##.....           ###            ###
           ....****    *****....
             ####        ####
           ######        ######
##############################################################
#...#......#.##...#......#.##...#......#.##------------------#
###########################################------------------#
#..#....#....##..#....#....##..#....#....#####################
##########################################    #----------#
#.....#......##.....#......##.....#......#    #----------#
##########################################    #----------#
#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#
##########################################    ############
```

## 输入格式

无

## 输出格式

如描述

## 提示

**广告**

洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)

[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)",字符串,,,,,"public class Main {
    public static void main(String[] args) {
        System.out.println(
            ""                ********\n"" +
            ""               ************\n"" +
            ""               ####....#.\n"" +
            ""             #..###.....##....\n"" +
            ""             ###.......######              ###            ###\n"" +
            ""                ...........               #...#          #...#\n"" +
            ""               ##*#######                 #.#.#          #.#.#\n"" +
            ""            ####*******######             #.#.#          #.#.#\n"" +
            ""           ...#***.****.*###....          #...#          #...#\n"" +
            ""           ....**********##.....           ###            ###\n"" +
            ""           ....****    *****....\n"" +
            ""             ####        ####\n"" +
            ""           ######        ######\n"" +
            ""##############################################################\n"" +
            ""#...#......#.##...#......#.##...#......#.##------------------#\n"" +
            ""###########################################------------------#\n"" +
            ""#..#....#....##..#....#....##..#....#....#####################\n"" +
            ""##########################################    #----------#\n"" +
            ""#.....#......##.....#......##.....#......#    #----------#\n"" +
            ""##########################################    #----------#\n"" +
            ""#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n"" +
            ""##########################################    ############\n""
        );
    }
}
",1
,"# A+B Problem

## 题目描述

输入两个整数 $a, b$，输出它们的和（$|a|,|b| \le {10}^9$）。

注意

1. Pascal 使用 `integer` 会爆掉哦！
2. 有负数哦！
3. C/C++ 的 main 函数必须是 `int` 类型，而且 C 最后要 `return 0`。这不仅对洛谷其他题目有效，而且也是 NOIP/CSP/NOI 比赛的要求！

好吧，同志们，我们就从这一题开始，向着大牛的路进发。

> 任何一个伟大的思想，都有一个微不足道的开始。

## 输入格式

两个以空格分开的整数。

## 输出格式

一个整数。

## 样例 #1

### 样例输入 #1

```
20 30
```

### 样例输出 #1

```
50
```

## 提示

**广告**

洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)

[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)

**本题各种语言的程序范例：**

C
```c
#include <stdio.h>

int main()
{
    int a,b;
    scanf(""%d%d"",&a,&b);
    printf(""%d\n"", a+b);
    return 0;
}
```
----------------

C++
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    int a,b;
    cin >> a >> b;
    cout << a+b << endl;
    return 0;
}
```
----------------

Pascal
```cpp
var a, b: longint;
begin
    readln(a,b);
    writeln(a+b);
end.
```
-----------------

Python2

```cpp
s = raw_input().split()
print int(s[0]) + int(s[1])
```
-----------------

Python3

```cpp
s = input().split()
print(int(s[0]) + int(s[1]))
```
-----------------

Java
```java
import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[]) throws Exception {
        Scanner cin=new Scanner(System.in);
        int a = cin.nextInt(), b = cin.nextInt();
        System.out.println(a+b);
    }
}
```
-----------------

JavaScript （Node.js）

```javascript
const fs = require('fs')
const data = fs.readFileSync('/dev/stdin')
const result = data.toString('ascii').trim().split(' ').map(x => parseInt(x)).reduce((a, b) => a + b, 0)
console.log(result)
process.exit() // 请注意必须在出口点处加入此行
```

-----------------

Ruby

```ruby
a, b = gets.split.map(&:to_i)
print a+b
```

-----------------

PHP

```php
<?php
$input = trim(file_get_contents(""php://stdin""));
list($a, $b) = explode(' ', $input);
echo $a + $b;
```

-----------------

Rust

```rust
use std::io;

fn main(){
    let mut input=String::new();
    io::stdin().read_line(&mut input).unwrap();
    let mut s=input.trim().split(' ');

    let a:i32=s.next().unwrap()
               .parse().unwrap();
    let b:i32=s.next().unwrap()
               .parse().unwrap();
    println!(""{}"",a+b);
}
```

-----------------

Go

```go
package main

import ""fmt""

func main() {
    var a, b int
    fmt.Scanf(""%d%d"", &a, &b)
    fmt.Println(a+b)
}
```

-----------------

C# Mono

```cs
using System;

public class APlusB{
    private static void Main(){
        string[] input = Console.ReadLine().Split(' ');
        Console.WriteLine(int.Parse(input[0]) + int.Parse(input[1]));
    }
}
```

------------------

Visual Basic Mono

```vb
Imports System

Module APlusB
    Sub Main()
        Dim ins As String() = Console.ReadLine().Split(New Char(){"" ""c})
        Console.WriteLine(Int(ins(0))+Int(ins(1)))
    End Sub
End Module
```

------------------

Kotlin

```kotlin
fun main(args: Array<String>) {
    val (a, b) = readLine()!!.split(' ').map(String::toInt)
    println(a + b)
}
```

------------------

Haskell

```haskell
main = do
    [a, b] <- (map read . words) `fmap` getLine
    print (a+b)
```

------------------

Lua

```lua
a = io.read('*n')
b = io.read('*n')
print(a + b)
```

------------------

OCaml

```ocaml
Scanf.scanf ""%i %i\n"" (fun a b -> print_int (a + b))
```

------------------

Julia

```julia
nums = map(x -> parse(Int, x), split(readline(), "" ""))
println(nums[1] + nums[2])
```

------------------

Scala

```scala
object Main extends App {
    println(scala.io.StdIn.readLine().split("" "").map(_.toInt).sum)
}
```

------------------

Perl

```perl
my $in = <STDIN>;
chomp $in;
$in = [split /[\s,]+/, $in];
my $c = $in->[0] + $in->[1];
print ""$c\n"";
```",大整数加法,,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a, b;
        a = scanner.nextInt();
        b = scanner.nextInt();
        System.out.println(a + b);
    }
}
",0
,"# 字符三角形

## 题目描述

给定一个字符，用它构造一个底边长 $5$ 个字符，高 $3$ 个字符的等腰字符三角形。

## 输入格式

输入只有一行，包含一个字符。

## 输出格式

该字符构成的等腰三角形，底边长 $5$ 个字符，高 $3$ 个字符。

## 样例 #1

### 样例输入 #1

```
*
```

### 样例输出 #1

```
*
 ***
*****
```

## 提示

对于 $100 \%$ 的数据，输入的字符是 ASCII 中的可见字符。",顺序结构,,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        char ch = scanner.next().charAt(0);
        System.out.printf(""  %c%n %c%c%c%n%c%c%c%c%c%n"", ch, ch, ch, ch, ch, ch, ch, ch, ch);
    }
}
",1
,"# 【深基2.例5】苹果采购

## 题目描述

现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？

## 输入格式

输入两个不超过 $10^9$ 正整数，分别表示每人分到的数量和同学的人数。

## 输出格式

一个整数，表示答案。保证输入和答案都在 int 范围内的非负整数。

## 样例 #1

### 样例输入 #1

```
5 3
```

### 样例输出 #1

```
15
```",输入输出Scanner,,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a, b;
        a = scanner.nextInt();
        b = scanner.nextInt();
        System.out.println(a * b);
    }
}",0
,"# 【深基2.例6】字母转换

## 题目描述

输入一个小写字母，输出其对应的大写字母。例如输入 q[回车] 时，会输出 Q。

## 输入格式

## 输出格式

## 样例 #1

### 样例输入 #1

```
q
```

### 样例输出 #1

```
Q
```",字符转换,,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        char ch = scanner.next().charAt(0);
        System.out.println(Character.toUpperCase(ch));
    }
}
",1
,"# 【深基2.例7】数字反转

## 题目描述

输入一个不小于 $100$ 且小于 $1000$，同时包括小数点后一位的一个浮点数，例如 $123.4$ ，要求把这个数字翻转过来，变成 $4.321$ 并输出。

## 输入格式

一行一个浮点数

## 输出格式

一行一个浮点数

## 样例 #1

### 样例输入 #1

```
123.4
```

### 样例输出 #1

```
4.321
```","浮点数,数字反转",,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.next();
        String[] parts = input.split(""\\."");
        String integerPart = parts[0];
        String decimalPart = parts[1];

        StringBuilder reversedInteger = new StringBuilder(integerPart).reverse();
        StringBuilder reversedDecimal = new StringBuilder(decimalPart).reverse();

        String output = reversedDecimal + ""."" + reversedInteger;
        System.out.println(output);
    }
}
",1
,"# 【深基2.例8】再分肥宅水

## 题目描述

现在有 $t$ 毫升肥宅快乐水，要均分给 $n$ 名同学。每名同学需要 $2$ 个杯子。现在想知道每名同学可以获得多少毫升饮料（严格精确到小数点后 $3$ 位），以及一共需要多少个杯子。

## 输入格式

输入一个实数 $t$ 和一个正整数 $n$，使用空格隔开。

## 输出格式

输出两行。

第一行输出一个三位小数，表示可以获得多少毫升饮料。第二行输出一个正整数，表示一共需要多少个杯子。

## 样例 #1

### 样例输入 #1

```
500.0 3
```

### 样例输出 #1

```
166.667
6
```

## 提示

对于所有数据，$0\leq t\leq 10000$ 且小数点后不超过 $3$ 位，$1\leq n\leq 1000$。","浮点数,顺序结构",,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double t = scanner.nextDouble(); // 总量
        int n = scanner.nextInt(); // 同学数量

        double perPerson = t / n; // 每人获得的量
        int totalCups = n * 2; // 总共需要的杯子数

        System.out.printf(""%.3f%n"", perPerson);
        System.out.println(totalCups);
    }
}
",1
,"# 【深基2.习2】三角形面积

## 题目描述

一个三角形的三边长分别是 $a$、$b$、$c$，那么它的面积为 $\sqrt{p(p-a)(p-b)(p-c)}$，其中 $p=\frac{1}{2}(a+b+c)$。输入这三个数字，计算三角形的面积，四舍五入精确到 $1$ 位小数。

## 输入格式

第一行输入三个实数 $a,b,c$，以空格隔开。

## 输出格式

输出一个实数，表示三角形面积。精确到小数点后 $1$ 位。

## 样例 #1

### 样例输入 #1

```
3 4 5
```

### 样例输出 #1

```
6.0
```

## 提示

数据保证能构成三角形，$0\leq a,b,c\leq 1000$，每个边长输入时不超过 $2$ 位小数。","浮点数,顺序结构",,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double a = scanner.nextDouble(); // 边长a
        double b = scanner.nextDouble(); // 边长b
        double c = scanner.nextDouble(); // 边长c

        double p = (a + b + c) / 2; // 半周长
        double area = Math.sqrt(p * (p - a) * (p - b) * (p - c)); // 海伦公式计算面积

        System.out.printf(""%.1f%n"", area);
    }
}
",1
,"# 【深基2.例12】上学迟到

## 题目描述

学校和 yyy 的家之间的距离为 $s$ 米，而 yyy 以 $v$ 米每分钟的速度匀速走向学校。

在上学的路上，yyy 还要额外花费 $10$ 分钟的时间进行垃圾分类。

学校要求必须在上午 $\textrm{8:00}$  到达，请计算在不迟到的前提下，yyy 最晚能什么时候出门。

由于路途遥远，yyy 可能不得不提前一点出发，但是提前的时间不会超过一天。

## 输入格式

一行两个正整数 $s,v$，分别代表路程和速度。

## 输出格式

输出一个 $24$ 小时制下的时间，代表 yyy 最晚的出发时间。

输出格式为 $\texttt{HH:MM}$，分别代表该时间的时和分。必须输出两位，不足前面补 $0$。

## 样例 #1

### 样例输入 #1

```
100 99
```

### 样例输出 #1

```
07:48
```

## 提示

对于 $100\%$ 的数据，$1 \le s,v \le 10^4$。","顺序结构,字符串",,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double s = scanner.nextDouble(); // 路程
        double v = scanner.nextDouble(); // 速度

        int n = 8 * 60 + 24 * 60; // 两天总共的分钟数
        int t = (int) Math.ceil(s / v) + 10; // 向上取整，加上垃圾分类的时间

        n = n - t; // 得出剩下的时间
        if (n >= 24 * 60) {
            n -= 24 * 60; // 判断是否在前一天
        }

        int b = n % 60; // 得出出发分
        int a = n / 60; // 得出出发时

        if (a < 10) { // 判断是否补0
            if (b < 10) {
                System.out.println(""0"" + a + "":0"" + b);
            } else {
                System.out.println(""0"" + a + "":"" + b);
            }
        } else {
            if (b < 10) {
                System.out.println(a + "":0"" + b);
            } else {
                System.out.println(a + "":"" + b);
            }
        }
    }
}
",2
,"# 大象喝水

## 题目描述

一只大象口渴了，要喝 $20$ 升水才能解渴，但现在只有一个深 $h$ 厘米，底面半径为 $r$ 厘米的小圆桶 （$h$ 和 $r$ 都是整数）。问大象至少要喝多少桶水才会解渴。

**Update：数据更新，这里我们近似地取圆周率 $\pi = 3.14$。**

## 输入格式

输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深 $h$ 和底面半径 $r$，单位都是厘米。

## 输出格式

输出一行，包含一个整数，表示大象至少要喝水的桶数。

## 样例 #1

### 样例输入 #1

```
23 11
```

### 样例输出 #1

```
3
```

## 提示

### 数据规模与约定
对于全部的测试点，保证 $1 \leq h \leq 500$，$1 \leq r \leq 100$。","顺序结构,字符串",,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int h = scanner.nextInt(); // 桶的深度
        int r = scanner.nextInt(); // 桶的底面半径

        double pi = 3.14; // 圆周率的近似值
        int waterNeeded = 20000; // 大象需要的水量

        // 计算至少需要喝水的桶数，向上取整
        int bucketsNeeded = (int) Math.ceil(waterNeeded / (pi * r * r * h));

        System.out.println(bucketsNeeded);
    }
}
",1
,"# 小鱼的游泳时间

## 题目描述

伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。

这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按 $24$ 小时制计算），它发现自己从 $a$ 时 $b$ 分一直游泳到当天的 $c$ 时 $d$ 分，请你帮小鱼计算一下，它这天一共游了多少时间呢？

小鱼游的好辛苦呀，你可不要算错了哦。

## 输入格式

一行内输入四个整数，以空格隔开，分别表示题目中的 $a, b, c, d$。

## 输出格式

一行内输出两个整数 $e$ 和 $f$，用空格间隔，依次表示小鱼这天一共游了多少小时多少分钟。其中表示分钟的整数 $f$ 应该小于 $60$。

## 样例 #1

### 样例输入 #1

```
12 50 19 10
```

### 样例输出 #1

```
6 20
```

## 提示

对于全部测试数据，$0\le a,c \le 24$，$0\le b,d \le 60$，且结束时间一定晚于开始时间。",顺序结构,,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt(); // 开始时间的小时数
        int b = scanner.nextInt(); // 开始时间的分钟数
        int c = scanner.nextInt(); // 结束时间的小时数
        int d = scanner.nextInt(); // 结束时间的分钟数

        int totalHours = c - a; // 总小时数
        int totalMinutes = d - b; // 总分钟数

        // 如果总分钟数小于0，则减去60分钟并加1小时
        if (totalMinutes < 0) {
            totalMinutes += 60;
            totalHours--;
        }

        System.out.println(totalHours + "" "" + totalMinutes);
    }
}
",1
,"# 小玉买文具

## 题目描述

班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 $1$ 元 $9$ 角，而班主任给小玉的钱是 $a$ 元 $b$ 角，小玉想知道，她最多能买多少只签字笔呢。

## 输入格式

输入只有一行两个整数，分别表示 $a$ 和 $b$。

## 输出格式

输出一行一个整数，表示小玉最多能买多少只签字笔。

## 样例 #1

### 样例输入 #1

```
10 3
```

### 样例输出 #1

```
5
```

## 提示

#### 数据规模与约定

对于全部的测试点，保证 $0 \leq a \leq 10^4$，$0 \leq b \leq 9$。","顺序结构,浮点数",,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt(); // 元
        int b = scanner.nextInt(); // 角

        // 计算总金额
        double totalMoney = a + b / 10.0;

        // 计算签字笔的价格
        double penPrice = 1.9;

        // 计算最多能买多少只签字笔
        int maxPens = (int) Math.floor(totalMoney / penPrice);

        System.out.println(maxPens);
    }
}
",1
,"## 题目背景

NOIP2017 普及组 T1

## 题目描述

牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：

$$
\text{总成绩}=\text{作业成绩}\times 20\%+\text{小测成绩}×30\%+\text{期末考试成绩} \times 50\%
$$

牛牛想知道，这门课程自己最终能得到多少分。

## 输入格式

三个非负整数 $A,B,C$，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 $100$ 分。

## 输出格式

一个整数，即牛牛这门课程的总成绩，满分也是 $100$ 分。

## 样例 #1

### 样例输入 #1

```
100 100 80
```

### 样例输出 #1

```
90
```

## 样例 #2

### 样例输入 #2

```
60 90 80
```

### 样例输出 #2

```
79
```

## 提示

**样例 1 说明**

牛牛的作业成绩是 $100$ 分，小测成绩是 $100$ 分，期末考试成绩是 $80$ 分，总成绩是 $100 \times 20\%+100 \times 30\%+80 \times 50\%=20+30+40=90$。

**样例 2 说明**

牛牛的作业成绩是 $60$ 分，小测成绩是 $90$ 分，期末考试成绩是 $80$ 分，总成绩是 $60 \times 20\%+90 \times 30\%+80 \times 50\%=12+27+40=79$。

**数据说明**

对于 $30\%$ 的数据，$A=B=0$。

对于另外 $30\%$ 的数据，$A=B=100$。

对于 $100\%$ 的数据，$0≤A,B,C≤100$ 且 $A,B,C$ 都是 $10$ 的整数倍。","顺序结构,整数",,,,,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int A = scanner.nextInt(); // 作业成绩
        int B = scanner.nextInt(); // 小测成绩
        int C = scanner.nextInt(); // 期末考试成绩

        // 计算总成绩
        int totalScore = (A * 20 + B * 30 + C * 50) / 100;

        System.out.println(totalScore);
    }
}
",0
,"# 【深基2.习6】Apples Prologue / 苹果和虫子

## 题目描述

小 B 喜欢吃苹果。她现在有 $m$（$1 \le m \le 100$）个苹果，吃完一个苹果需要花费 $t$（$0 \le t \le 100$）分钟，吃完一个后立刻开始吃下一个。现在时间过去了 $s$（$1 \le s \le 10000$）分钟，请问她还有几个完整的苹果？

## 输入格式

输入三个**非负整数**表示 $m, t, s$。

## 输出格式

输出一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
50 10 200
```

### 样例输出 #1

```
30
```

## 提示

如果你出现了 RE，不如检查一下被零除？",分支结构,,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  float b = sc.nextFloat();
  int c = sc.nextInt();
  if (b == 0) {
   b = a;
   a = 0;
   if(c == 0)
    a = (int)b;
  } else {
   a -= Math.ceil(c / b);
   if (a < 0)
    a = 0;
  }
   System.out.println(a);
 }
}",1
,"# 【深基3.例2】数的性质

## 题目描述

一些整数可能拥有以下的性质：

- 性质 1：是偶数；
- 性质 2：大于 $4$ 且不大于 $12$。

小 A 喜欢这两个性质同时成立的整数；Uim 喜欢这至少符合其中一种性质的整数；小 B 喜欢刚好有符合其中一个性质的整数；正妹喜欢不符合这两个性质的整数。现在给出一个整数 $x$，请问他们是否喜欢这个整数？

## 输入格式

输入一个整数 $x(0\le x \le 1000)$

## 输出格式

输出这 $4$ 个人是否喜欢这个数字，如果喜欢则输出 `1`，否则输出 `0`，用空格分隔。输出顺序为：小 A、Uim、小 B、正妹。

## 样例 #1

### 样例输入 #1

```
12
```

### 样例输出 #1

```
1 1 0 0
```","分支结构,整数",,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int x[] = new int[4];//x数组分别表示四个人
  x[0] = x[1] = 0;
  x[2] = 1;
  x[3] = 2;
  int a = sc.nextInt();
  if ((a%2) == 0) {
   x[0] += 1;
   x[1] += 2;
   x[2] += 3;
   x[3]  = 0;
  }
  if(a>4 && a<=12) {
   x[0] += 1;
   x[1] += 2;
   x[2] += 3;
   x[3]  = 0;
  }
  for(int i = 0;i<x.length;i++) {
   if(x[i] == 2 || x[i] == 4)
    x[i] = 1;
   else
    x[i] = 0;
   System.out.printf(""%d "",x[i]);
  }
  
 }
}",1
,"# 【深基3.例3】闰年判断

## 题目描述

输入一个年份，判断这一年是否是闰年，如果是输出 $1$，否则输出 $0$。

$1582$ 年以来，闰年的定义：

普通闰年：公历年份是 $4$ 的倍数，且不是 $100$ 的倍数的，为闰年（如 $2004$ 年、$2020$ 年等就是闰年）。

世纪闰年：公历年份是整百数的，必须是 $400$ 的倍数才是闰年（如 $1900$ 年不是闰年，$2000$ 年是闰年）。

## 输入格式

输入一个正整数 $n$，表示年份。

## 输出格式

输出一行。如果输入的年份是闰年则输出 $1$，否则输出 $0$。

## 样例 #1

### 样例输入 #1

```
1926
```

### 样例输出 #1

```
0
```

## 样例 #2

### 样例输入 #2

```
1900
```

### 样例输出 #2

```
0
```

## 样例 #3

### 样例输入 #3

```
2000
```

### 样例输出 #3

```
1
```

## 样例 #4

### 样例输入 #4

```
1996
```

### 样例输出 #4

```
1
```

## 提示

数据保证，$1582 \leq n \leq 2020$ 且年份为自然数。",分支结构,,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  if (((a % 4 == 0) && (a % 100 != 0)) || a % 400 == 0)
   System.out.println(1);
  else
   System.out.println(0);
 }
}",1
,"# 【深基3.例4】Apples

## 题目描述

小 B 喜欢吃苹果。她今天吃掉了 $x$ 个苹果。英语课上学到了 apple 这个词语，想用它来造句。如果她吃了 1 个苹果，就输出 `Today, I ate 1 apple.`；如果她没有吃，那么就把 1 换成 0；如果她吃了不止一个苹果，别忘了 `apple` 这个单词后面要加上代表复数的 `s`。你能帮她完成这个句子吗？

## 输入格式

输入一行一个自然数 $x$，表示吃掉的苹果数。

## 输出格式

根据题目要求输出。

## 样例 #1

### 样例输入 #1

```
1
```

### 样例输出 #1

```
Today, I ate 1 apple.
```

## 样例 #2

### 样例输入 #2

```
3
```

### 样例输出 #2

```
Today, I ate 3 apples.
```

## 提示

对于所有数据，$0\le x \le 100$。","分支结构,字符串",,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  if(a <= 1)
   System.out.printf(""Today, I ate %d apple."",a);
  else
   System.out.printf(""Today, I ate %d apples."",a);
 }
}",1
,"# 【深基3.例5】洛谷团队系统

## 题目描述

在洛谷上使用团队系统非常方便的添加自己的题目。如果在自己的电脑上配置题目和测试数据，每题需要花费时间 $5$ 分钟；而在洛谷团队中上传私有题目，每题只需要花费 $3$ 分钟，但是上传题目之前还需要一次性花费 $11$ 分钟创建与配置团队。现在要配置 $n$ 道题目，如果本地配置花费的总时间短，请输出 `Local`，否则输出 `Luogu`。

## 输入格式

输入一个正整数 $n$，表示需要配置的题目量。

## 输出格式

输出一行，一个字符串。如果本地配置花费的总时间短，请输出 `Local`，否则输出 `Luogu`。

## 样例 #1

### 样例输入 #1

```
2
```

### 样例输出 #1

```
Local
```

## 样例 #2

### 样例输入 #2

```
50
```

### 样例输出 #2

```
Luogu
```

## 提示

数据保证 $1 \leq n\leq 100$。","分支结构,字符串",,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  int b = a*5;
  int c = 11 + a*3;
  String d;
  d = b<c?""Local"":""Luogu"";
  System.out.println(d);
 }
}",1
,"# 【深基3.例7】肥胖问题

## 题目描述

BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 $\dfrac{m}{h^2}$，其中 $m$ 是指体重（千克），$h$ 是指身高（米）。不同体型范围与判定结果如下：

- 小于 $18.5$：体重过轻，输出 `Underweight`；
- 大于等于 $18.5$ 且小于 $24$：正常体重，输出 `Normal`；
- 大于等于 $24$：肥胖，不仅要输出 BMI 值（使用 `cout` 的默认精度），然后换行，还要输出 `Overweight`；

现在给出体重和身高数据，需要根据 BMI 指数判断体型状态并输出对应的判断。

对于非 C++ 语言，在输出时，请四舍五入保留六位**有效数字**输出，如果小数部分存在后缀 $0$，不要输出后缀 $0$。

请注意，保留六位**有效数字**不是保留六位小数。例如 $123.4567$ 应该输出为 $123.457$，$5432.10$ 应该输出为 $5432.1$。

## 输入格式

共一行。

第一行，共 $2$ 个浮点数，$m, h$，分别表示体重（单位为 kg），身高（单位为 m）。

## 输出格式

输出一行一个字符串，表示根据 BMI 的对应判断。特别地，对于 `Overweight` 情况的特别处理请参照题目所述。

## 样例 #1

### 样例输入 #1

```
70 1.72
```

### 样例输出 #1

```
Normal
```

## 样例 #2

### 样例输入 #2

```
100 1.68
```

### 样例输出 #2

```
35.4308
Overweight
```

## 提示

对于所有数据，$40\le m \le 120$，$1.4 \le h \le 2.0$。$m$ 和 $h$ 的小数点后不超过三位。","分支结构,浮点数,字符串",,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  float a = sc.nextFloat();
  float b = sc.nextFloat();
  float c = (a/(b*b))*10;
  if(c<185)
   System.out.println(""Underweight"");
  else if(c < 240)
   System.out.println(""Normal"");
  else
   System.out.printf(""%.4f\nOverweight"",c/10);
 }
}",2
,"# 【深基3.例8】三位数排序

## 题目描述

给出三个整数 $a,b,c(0\le a,b,c \le 100)$，要求把这三位整数从小到大排序。

## 输入格式

输入三个整数 $a,b,c$，以空格隔开。

## 输出格式

输出一行，三个整数，表示从小到大排序后的结果。

## 样例 #1

### 样例输入 #1

```
1 14 5
```

### 样例输出 #1

```
1 5 14
```

## 样例 #2

### 样例输入 #2

```
2 2 2
```

### 样例输出 #2

```
2 2 2
```","分支结构,数字排序",,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int[] arr = new int[3];
  for (int n = 0; n < 3; n++) {
   arr[n] = sc.nextInt();
  }
  for (int i = 0; i < 2; i++) {
   for (int k = 0; k < 2; k++) {
    if (arr[k] > arr[k + 1]) {
     int a = arr[k];
     arr[k] = arr[k + 1];
     arr[k + 1] = a;
    }
   }
   if(i == 1)
    System.out.printf(""%d %d %d"",arr[0],arr[1],arr[2]);
  }
 }
}",2
,"# 【深基3.例9】月份天数

## 题目描述

输入年份和月份，输出这一年的这一月有多少天。需要考虑闰年。

## 输入格式

输入两个正整数，分别表示年份 $y$ 和月数 $m$，以空格隔开。

## 输出格式

输出一行一个正整数，表示这个月有多少天。

## 样例 #1

### 样例输入 #1

```
1926 8
```

### 样例输出 #1

```
31
```

## 样例 #2

### 样例输入 #2

```
2000 2
```

### 样例输出 #2

```
29
```

## 提示

数据保证 $1583 \leq y \leq 2020$，$1 \leq m \leq 12$。",分支结构,,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int year = sc.nextInt();
  int month = sc.nextInt();
  switch (month) {
  case 1:
  case 3:
  case 5:
  case 7:
  case 8:
  case 10:
  case 12:
   System.out.println(31);
   break;
  case 4:
  case 6:
  case 9:
  case 11:
   System.out.println(30);
   break;
  }
  if (month == 2) {
   if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
    System.out.println(29);
   }
   else
    System.out.println(28);
  }
 }
}",2
,"# [NOIP2004 普及组] 不高兴的津津

## 题目描述

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。

## 输入格式

输入包括 $7$ 行数据，分别表示周一到周日的日程安排。每行包括两个小于 $10$ 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。

## 输出格式

一个数字。如果不会不高兴则输出 $0$，如果会则输出最不高兴的是周几（用 $1, 2, 3, 4, 5, 6, 7$ 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。

## 样例 #1

### 样例输入 #1

```
5 3
6 2
7 2
5 3
5 4
0 4
0 6
```

### 样例输出 #1

```
3
```

## 提示

NOIP2004 普及组第 1 题

- 2021-10-27：增加一组 hack 数据
- 2022-06-05：又增加一组 hack 数据",分支结构,,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = 0;
  int n = 0;
  int[] arr = new int[14];
  for (int i = 0; i < 14; i++)
   arr[i] = sc.nextInt();
  for (int k = 0; k < 7; k++) {
   if (a < arr[2 * k] + arr[2 * k + 1]) {
    a = arr[2 * k] + arr[2 * k + 1];
    n = k;
   }
  }
  if (a > 8)
   System.out.println(n + 1);
  else
   System.out.println(0);
 }
}",2
,"# [NOIP2016 普及组] 买铅笔

## 题目背景

NOIP2016 普及组 T1

## 题目描述

P 老师需要去商店买 $n$ 支铅笔作为小朋友们参加 NOIP 的礼物。她发现商店一共有 $3$ 种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P 老师决定只买同一种包装的铅笔。

商店不允许将铅笔的包装拆开，因此 P 老师可能需要购买超过 $n$ 支铅笔才够给小朋友们发礼物。

现在 P 老师想知道，在商店每种包装的数量都足够的情况下，要买够至少 $n$ 支铅笔最少需要花费多少钱。

## 输入格式

第一行包含一个正整数 $n$，表示需要的铅笔数量。

接下来三行，每行用 $2$ 个正整数描述一种包装的铅笔：其中第 $1$ 个整数表示这种包装内铅笔的数量，第 $2$ 个整数表示这种包装的价格。

保证所有的 $7$ 个数都是不超过 $10000$ 的正整数。

## 输出格式

$1$ 个整数，表示 P 老师最少需要花费的钱。

## 样例 #1

### 样例输入 #1

```
57
2 2
50 30
30 27
```

### 样例输出 #1

```
54
```

## 样例 #2

### 样例输入 #2

```
9998
128 233
128 2333
128 666
```

### 样例输出 #2

```
18407
```

## 样例 #3

### 样例输入 #3

```
9999
101 1111
1 9999
1111 9999
```

### 样例输出 #3

```
89991
```

## 提示

铅笔的三种包装分别是：

- $2$ 支装，价格为 $2$;
- $50$ 支装，价格为 $30$;
- $30$ 支装，价格为 $27$。

P 老师需要购买至少 $57$ 支铅笔。

如果她选择购买第一种包装，那么她需要购买 $29$ 份，共计 $2 \times 29 = 58$ 支，需要花费的钱为 $2 \times 29 = 58$。

实际上，P 老师会选择购买第三种包装，这样需要买 $2$ 份。虽然最后买到的铅笔数量更多了，为 $30 \times 2 = 60$ 支，但花费却减少为 $27 \times 2 = 54$，比第一种少。

对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买 $2$ 份，实际的花费达到了 $30  \times 2 = 60$，因此 P 老师也不会选择。

所以最后输出的答案是 $54$。

**数据范围**

保证所有的 $7$ 个数都是不超过 $10000$ 的正整数。

**子任务**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/dlgsz3h4.png)

上表中“整倍数”的意义为：若为 $K$，表示对应数据所需要的铅笔数量 $n$ ―定是每种包装铅笔数量的整倍数（这意味着一定可以不用多买铅笔）。

于 2022 年 12 月 23 日新加 Hack 数据三组。",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  int b1 = sc.nextInt();
  int c1 = sc.nextInt();
  int b2 = sc.nextInt();
  int c2 = sc.nextInt();
  int b3 = sc.nextInt();
  int c3 = sc.nextInt();
  int d1 = (a % b1 == 0 ? a / b1 : a / b1 + 1) * c1;
  int d2 = (a % b2 == 0 ? a / b2 : a / b2 + 1) * c2;
  int d3 = (a % b3 == 0 ? a / b3 : a / b3 + 1) * c3;
  int d4 = Math.min(d1, d2);
  int d = Math.min(d4, d3);
  System.out.println(d);
 }
}",2
,"# 【深基3.习8】三角形分类

## 题目描述

给出三条线段 $a,b,c$ 的长度，均是不大于 $10000$ 的正整数。打算把这三条线段拼成一个三角形，它可以是什么三角形呢？

- 如果三条线段不能组成一个三角形，输出`Not triangle`；
- 如果是直角三角形，输出`Right triangle`；
- 如果是锐角三角形，输出`Acute triangle`；
- 如果是钝角三角形，输出`Obtuse triangle`；
- 如果是等腰三角形，输出`Isosceles triangle`；
- 如果是等边三角形，输出`Equilateral triangle`。

如果这个三角形符合以上多个条件，请按以上顺序分别输出，并用换行符隔开。

## 输入格式

输入 3 个整数 $a$、$b$ 和 $c$。

## 输出格式

输出若干行判定字符串。

## 样例 #1

### 样例输入 #1

```
3 3 3
```

### 样例输出 #1

```
Acute triangle
Isosceles triangle
Equilateral triangle
```

## 样例 #2

### 样例输入 #2

```
3 4 5
```

### 样例输出 #2

```
Right triangle
```

## 样例 #3

### 样例输入 #3

```
6 10 6
```

### 样例输出 #3

```
Obtuse triangle
Isosceles triangle
```

## 样例 #4

### 样例输入 #4

```
1 14 5
```

### 样例输出 #4

```
Not triangle
```

## 提示

当两短边的平方和大于一长边的平方，说明是锐角三角形。

当两短边的平方和等于一长边的平方，说明是直角三角形。

当两短边的平方和小于一长边的平方，说明是钝角三角形。",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  int b = sc.nextInt();
  int c = sc.nextInt();
  int a1 = Math.max(a, Math.max(c, b));
  int b1 = Math.min(a, Math.min(b, c));
  int c1 = a + b + c - a1 - b1;
  if (a1 >= b1 + c1)
   System.out.println(""Not triangle"");
  else {
   if (a1 * a1 == b1 * b1 + c1 * c1)
    System.out.println(""Right triangle"");
   if (a1 * a1 < b1 * b1 + c1 * c1)
    System.out.println(""Acute triangle"");
   if (a1 * a1 > b1 * b1 + c1 * c1)
    System.out.println(""Obtuse triangle"");
   if (b1 == c1 || a1 == c1)
    System.out.println(""Isosceles triangle"");
   if (a1 == b1)
    System.out.println(""Equilateral triangle"");
  }
 }
}",2
,"# 小玉家的电费

## 题目描述

夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电 [2006]27 号规定，月用电量在 $150$ 千瓦时及以下部分按每千瓦时 $0.4463$ 元执行，月用电量在 $151\sim 400$ 千瓦时的部分按每千瓦时 $0.4663$ 元执行，月用电量在 $401$ 千瓦时及以上部分按每千瓦时 $0.5663$ 元执行;小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。

## 输入格式

输入一个正整数，表示用电总计（单位以千瓦时计），不超过 $10000$。

## 输出格式

输出一个数，保留到小数点后 $1$ 位（单位以元计，保留到小数点后 $1$ 位）。

## 样例 #1

### 样例输入 #1

```
267
```

### 样例输出 #1

```
121.5
```",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  double b = 0;
  if (a > 150)
   if (a > 400)
    b = 150 * 0.4463 + 250 * 0.4663 + (a - 400) * 0.5663;
   else
    b = 150 * 0.4463 + (a - 150) * 0.4663;
  else
   b = a * 0.4463;
  b *= 10;
  b = Math.round(b);
  System.out.println(b / 10);
 }
}",1
,"# 小鱼的航程（改进版）

## 题目背景

## 题目描述

有一只小鱼，它平日每天游泳 $250$ 公里，周末休息（实行双休日)，假设从周 $x$ 开始算起，过了 $n$ 天以后，小鱼一共累计游泳了多少公里呢？

## 输入格式

输入两个正整数 $x,n$，表示从周 $x$ 算起，经过 $n$ 天。

## 输出格式

输出一个整数，表示小鱼累计游泳了多少公里。

## 样例 #1

### 样例输入 #1

```
3 10
```

### 样例输出 #1

```
2000
```

## 提示

数据保证，$1\le x \le 7$，$1 \le n\le 10^6$。",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = 0;
        for (; b > 0; b--) {
            if (a == 8)
                a = 1;
            if (a <= 5)
                c += 250;
 
            a++;
        }
        System.out.println(c);
    }
}",1
,"# 三角函数

## 题目描述

输入一组勾股数 $a,b,c（a\neq b\neq c）$，用分数格式输出其较小锐角的正弦值。（要求约分。）

## 输入格式

一行，包含三个正整数，即勾股数 $a,b,c$（无大小顺序）。

## 输出格式

一行，包含一个分数，即较小锐角的正弦值

## 样例 #1

### 样例输入 #1

```
3 5 4
```

### 样例输出 #1

```
3/5
```

## 提示

数据保证：$a,b,c$ 为正整数且 $\in [1,10^9]$。",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  int b = sc.nextInt();
  int c = sc.nextInt();
  int d = Math.min(a, Math.min(b, c));
  int e = Math.max(a, Math.max(b, c));
  int f = abc(d,e);
  if(f==0)
   f=1;
  System.out.printf(""%d/%d"",d/f,e/f);
 }
 
 public static int abc(int a, int b) {
  int c = Math.max(a, b);
  b = a + b - c;
  a = c;
  if (a % b != 0)
   return abc(a % b, b);
  else
   return b;
 
 }
}",2
,"# [NOIP2005 普及组] 陶陶摘苹果

## 题目描述

陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 $10$ 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 $30$ 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。


现在已知 $10$ 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。

## 输入格式

输入包括两行数据。第一行包含 $10$ 个 $100$ 到 $200$ 之间（包括 $100$ 和 $200$）的整数（以厘米为单位）分别表示 $10$ 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 $100$ 到 $120$ 之间（包含 $100$ 和 $120$）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。

## 输出格式

输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。

## 样例 #1

### 样例输入 #1

```
100 200 150 140 129 134 167 198 200 111
110
```

### 样例输出 #1

```
5
```

## 提示

**【题目来源】**

NOIP 2005 普及组第一题",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  int[] arr = new int[10];
  Scanner sc = new Scanner(System.in);
  for (int i = 0; i < 10; i++) {
   arr[i] = sc.nextInt();
  }
  int a = sc.nextInt();
  a+=30;
  int n = 0;
  for(int i = 0;i<10;i++) {
   if(arr[i] <= a)
    n++;
  }
  System.out.println(n);
 }
}",2
,"# [COCI2006-2007#2] ABC

## 题面翻译

**【题目描述】**

三个整数分别为 $A,B,C$。这三个数字不会按照这样的顺序给你，但它们始终满足条件：$A < B < C$。为了看起来更加简洁明了，我们希望你可以按照给定的顺序重新排列它们。

**【输入格式】**

第一行包含三个正整数 $A,B,C$，不一定是按这个顺序。这三个数字都小于或等于 $100$。第二行包含三个大写字母 $A$、$B$ 和 $C$（它们之间**没有**空格）表示所需的顺序。

**【输出格式】**

在一行中输出 $A$，$B$ 和 $C$，用一个 ` `（空格）隔开。


## 题目描述

You will be given three integers A, B and C. The numbers will not be given in that exact order, but we do know that A is less than B and B less than C.
In order to make for a more pleasant viewing, we want to rearrange them in the given order.

## 输入格式

The first line contains three positive integers A, B and C, not necessarily in that order. All three numbers will be less than or equal to 100.
The second line contains three uppercase letters 'A', 'B' and 'C' (with no spaces between them) representing the desired order.

## 输出格式

Output the A, B and C in the desired order on a single line, separated by single spaces.

## 样例 #1

### 样例输入 #1

```
1 5 3
ABC
```

### 样例输出 #1

```
1 3 5
```

## 样例 #2

### 样例输入 #2

```
6 4 2
CAB
```

### 样例输出 #2

```
6 2 4
```",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a = sc.nextInt();
  int b = sc.nextInt();
  int c = sc.nextInt();
  int a1, b1, c1;
  String d = sc.next();
  a1 = Math.max(a, Math.max(b, c));
  b1 = Math.min(a, Math.min(b, c));
  c1 = a + b + c - a1 - b1;
  int[] arr = new int[3];
  for (int i = 0; i < 3; i++) {
   switch (d.charAt(i)) {
   case 65:
    arr[i] = b1;
    break;
   case 66:
    arr[i] = c1;
    break;
   case 67:
    arr[i] = a1;
    break;
   }
   System.out.printf(""%d "",arr[i]);
  }
 
 }
}",2
,"# [NOIP2008 普及组] ISBN 号码

## 题目描述

每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 $9$ 位数字、$1$ 位识别码和 $3$ 位分隔符，其规定格式如 `x-xxx-xxxxx-x`，其中符号 `-` 就是分隔符（键盘上的减号），最后一位是识别码，例如 `0-670-82162-4`就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 $0$ 代表英语；第一个分隔符 `-` 之后的三位数字代表出版社，例如 $670$ 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以 $1$ 加上次位数字乘以 $2$ ……以此类推，用所得的结果 $ \bmod 11$，所得的余数即为识别码，如果余数为 $10$，则识别码为大写字母 $X$。例如 ISBN 号码 `0-670-82162-4` 中的识别码 $4$ 是这样得到的：对 `067082162` 这 $9$ 个数字，从左至右，分别乘以 $1,2,\dots,9$ 再求和，即 $0\times 1+6\times 2+……+2\times 9=158$，然后取 $158 \bmod 11$ 的结果 $4$ 作为识别码。

你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 `Right`；如果错误，则输出你认为是正确的 ISBN 号码。

## 输入格式

一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。

## 输出格式

一行，假如输入的 ISBN 号码的识别码正确，那么输出 `Right`，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 `-`）。

## 样例 #1

### 样例输入 #1

```
0-670-82162-4
```

### 样例输出 #1

```
Right
```

## 样例 #2

### 样例输入 #2

```
0-670-82162-0
```

### 样例输出 #2

```
0-670-82162-4
```

## 提示

2008 普及组第一题",分支结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  String str = sc.next();
  int a = 0;
  int n = 0;
  for (int i = 0; i < 11; i++) {
   if (str.charAt(i) == '-')
    continue;
   else {
    n++;
    a += ((int) str.charAt(i) - '0') * n;
   }
  }
  String c = a%11+"""";
   if ((int) str.charAt(str.length() - 1) == ((a%11 + '0')>'9'?'X':(a%11+'0')))
    System.out.println(""Right"");
   else
    System.out.printf(""%11.11s-%s"", str, c.equals(""10"")?""X"":c);
 }
}",2
,"# 距离函数

## 题目描述

给出平面坐标上不在一条直线上三个点坐标 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，坐标值是实数，且绝对值不超过 100.00，求围成的三角形周长。保留两位小数。

对于平面上的两个点 $(x_1,y_1),(x_2,y_2)$，则这两个点之间的距离 $dis=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$

## 输入格式

输入三行，第 $i$ 行表示坐标 $(x_i,y_i)$，以一个空格隔开。

## 输出格式

输出一个两位小数，表示由这三个坐标围成的三角形的周长。

## 样例 #1

### 样例输入 #1

```
0 0
0 3
4 0
```

### 样例输出 #1

```
12.00
```

## 提示

数据保证，坐标均为实数且绝对值不超过 $100$，小数点后最多仅有 $3$ 位。",函数与结构体,,,,,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        double x1 = sc.nextDouble();
        double y1 = sc.nextDouble();
        double x2 = sc.nextDouble();
        double y2 = sc.nextDouble();
        double x3 = sc.nextDouble();
        double y3 = sc.nextDouble();
        double c = distance(x1,y1,x2,y2) + distance(x1,y1,x3,y3) + distance(x2,y2,x3,y3);
        System.out.printf(""%.2f"",c);
    }
    public static double distance(double x1,double y1,double x2,double y2){
        return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
    }
}",0
,"# 质数筛

## 题目描述

输入 $n$ 个不大于 $10^5$ 的正整数。要求全部储存在数组中，去除掉不是质数的数字，依次输出剩余的质数。

## 输入格式

第一行输入一个正整数 $n$，表示整数个数。

第二行输入 $n$ 个正整数 $a_i$，以空格隔开。

## 输出格式

输出一行，依次输出 $a_i$ 中剩余的质数，以空格隔开。

## 样例 #1

### 样例输入 #1

```
5
3 4 5 6 7
```

### 样例输出 #1

```
3 5 7
```

## 提示

数据保证，$1\le n\le100$，$1 \leq a_i \leq 10^5$。",函数与结构体,,,,,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        StringBuilder c = new StringBuilder();
        for(int i = 0 ;i < a ;i++){
            int b = sc.nextInt();
            if(pri(b))
              c.append(b).append("" "");
        }
        System.out.print(c);
    }
    public static boolean pri(int x){
        if(x == 1)
            return false;
        else{
            if(x % 2 != 0 || x == 2) {
                for (int i = 3; i <= Math.sqrt(x); i += 2) {
                    if (x % i == 0)
                        return false;
                }
                return true;
            }
        }
        return false;
    }
}",1
,"# 闰年展示

## 题目描述

输入 $x,y$，输出 $[x,y]$ 区间中闰年个数，并在下一行输出所有闰年年份数字，使用空格隔开。

## 输入格式

输入两个正整数 $x,y$，以空格隔开。

## 输出格式

第一行输出一个正整数，表示 $[x,y]$ 区间中闰年个数。

第二行输出若干个正整数，按照年份单调递增的顺序输出所有闰年年份数字。

## 样例 #1

### 样例输入 #1

```
1989 2001
```

### 样例输出 #1

```
3
1992 1996 2000
```

## 提示

数据保证，$1582\le x < y \le 3000$。",函数与结构体,,,,,"import java.util.Scanner;
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        int a = 0;
        String str = """";
        for(;x<=y;x++){
            if(x%400 == 0 || (x%4 == 0 && x%100!= 0)){
                a++;
                str = str+x+"" "";
            }
        }
        System.out.println(a);
        System.out.println(str.trim()); //删除字符串的头尾空白符
    }
}",0
,"# 歌唱比赛

## 题目描述

$n(n\le 100)$ 名同学参加歌唱比赛，并接受 $m(m\le 20)$ 名评委的评分，评分范围是 $0$ 到 $10$ 分。这名同学的得分就是这些评委给分中去掉一个最高分，去掉一个最低分，剩下 $m-2$ 个评分的平均数。请问得分最高的同学分数是多少？评分保留 $2$ 位小数。

## 输入格式

第一行两个整数 $n,m$。   
接下来 $n$ 行，每行各 $m$ 个整数，表示得分。

## 输出格式

输出分数最高的同学的分数，保留两位小数。

## 样例 #1

### 样例输入 #1

```
7 6
4 7 2 6 10 7
0 5 0 10 3 10
2 6 8 4 3 6
6 3 6 7 5 8
5 9 3 3 8 1
5 9 9 3 2 0
5 8 0 4 1 10
```

### 样例输出 #1

```
6.00
```",函数与结构体,,,,,"import java.util.Scanner;
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        double score = 0; //最高平均分
        for(int i = 0 ;i<a;i++){
            int s = 0;  //sum――总分
            int m = 0;  //max――最高分
            int n = 10; //min――最低分
            for(int k = 0;k<b;k++){
                int c = sc.nextInt(); //当前打分
                s +=c;
                if(c<n)
                    n = c;
                if(c>m)
                    m = c;
            }
            double s1 = (s-m-n)/(b-2.0); //当前平均分
            if(s1 > score)
                score = s1;
        }
        System.out.printf(""%.2f"",score);
    }
}",1
,"# 计算阶乘

## 题目描述

求 $n!$，也就是 $1\times2\times3\dots\times n$。

挑战：尝试不使用循环语句（for、while）完成这个任务。

## 输入格式

第一行输入一个正整数 $n$。

## 输出格式

输出一个正整数，表示 $n!$。

## 样例 #1

### 样例输入 #1

```
3
```

### 样例输出 #1

```
6
```

## 提示

数据保证，$1 \leq n\le12$。","函数与结构体,模拟,递归",,,,,"import java.util.Scanner;
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(fac(sc.nextInt()));
    }
    public  static  int fac(int x){
        if(x != 1)
            return x*fac(x-1);
        else
            return 1;
    }
}",0
,"# 赦免战俘

## 题目背景

借助反作弊系统，一些在月赛有抄袭作弊行为的选手被抓出来了！

## 题目描述

现有 $2^n\times 2^n (n\le10)$ 名作弊者站成一个正方形方阵等候 kkksc03 的发落。kkksc03 决定赦免一些作弊者。他将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有作弊者都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免作弊者……直到矩阵无法再分下去为止。所有没有被赦免的作弊者都将被处以棕名处罚。

给出 $n$，请输出每名作弊者的命运，其中 0 代表被赦免，1 代表不被赦免。

## 输入格式

一个整数 $n$。

## 输出格式

$2^n \times 2^n$ 的 01 矩阵，代表每个人是否被赦免。数字之间有一个空格。

## 样例 #1

### 样例输入 #1

```
3
```

### 样例输出 #1

```
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```","函数与结构体,模拟,递归",,,,,"import java.util.Scanner;
public class Main {
 
    public static void main(String[] args) {
 public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = (int)Math.pow(2,a);
        boolean[][] ans = new boolean[b][b];
        ans[0][b-1] = true;
        for(int c = 0;c<a;c++){
            int diff = 1;
            for(int i = 0;i<2;i++){
                for(int m = 0;m<(int)Math.pow(2,c);m++){
                    int d  = (int) Math.pow(2, c);
                    System.arraycopy(ans[d - 1 - m], b - d, ans[d*2 - 1 - m], b - (d*2 / diff), d);
                    //等第一处全部拷贝完成后，再去拷贝第二处
                }
                diff = 2;
            }
        }
        for(int i = 0 ;i<b;i++){
            for(int k = 0;k<b;k++){
                if(ans[i][k])
                    System.out.print(""1 "");
                else
                    System.out.print(""0 "");
            }
            System.out.println();
        }
    }
}",2
,"# 最厉害的学生

## 题目描述

现有 $N$ 名同学参加了期末考试，并且获得了每名同学的信息：姓名（不超过 $8$ 个字符的仅有英文小写字母的字符串）、语文、数学、英语成绩（均为不超过 $150$ 的自然数）。总分最高的学生就是最厉害的，请输出最厉害的学生各项信息（姓名、各科成绩）。如果有多个总分相同的学生，输出靠前的那位。

## 输入格式

第一行输入一个正整数 $N$，表示学生个数。

第二行开始，往下 $N$ 行，对于每一行首先先输入一个字符串表示学生姓名，再输入三个自然数表示语文、数学、英语的成绩。均用空格相隔。

## 输出格式

输出最厉害的学生。

## 样例 #1

### 样例输入 #1

```
3
senpai 114 51 4
lxl 114 10 23
fafa 51 42 60
```

### 样例输出 #1

```
senpai 114 51 4
```

## 提示

数据保证，$1 \leq N \leq 1000$，姓名为长度不超过 $8$ 的字符串，语文、数学、英语成绩均为不超过 $150$ 的自然数。",函数与结构体,,,,,"import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a  = sc.nextInt();
        score[] ss = new score[a];
        for(int i = 0;i<a;i++) {
            String name = sc.next();
            int s1 = sc.nextInt();
            int s2 = sc.nextInt();
            int s3 = sc.nextInt();
            score s = new score(name,s1,s2,s3);
            ss[i] = s;
        }
        Arrays.sort(ss);
        System.out.println(ss[0].toString());
    }
 
}
class score implements Comparable<score> {
    private  String name;
    private int sum;
    private int s1;
    private int s2;
    private int s3;
 
 
    public score(String name, int s1, int s2, int s3) {
        this.name = name;
        this.sum = s1+s2+s3;
        this.s1 = s1;
        this.s2 = s2;
        this.s3 = s3;
    }
 
 
    @Override
    public int compareTo(score o) {
        return Integer.compare(o.sum, this.sum);
    }
 
    @Override
    public String toString() {
        return name+"" ""+s1+"" ""+s2+"" ""+s3;
    }
}",1
,"# 旗鼓相当的对手 - 加强版

## 题目描述

现有 $N(N\le 1000)$ 名同学参加了期末考试，并且获得了每名同学的信息：姓名（不超过 $8$ 个字符的字符串，没有空格）、语文、数学、英语成绩（均为不超过 $150$ 的自然数）。如果某对学生 $\text{<}i,j\text{>}$ 的每一科成绩的分差都不大于 $5$，且总分分差不大于 $10$，那么这对学生就是“旗鼓相当的对手”。现在我们想知道这些同学中，哪些是“旗鼓相当的对手”？请输出他们的姓名。

所有人的姓名是按照字典序给出的，输出时也应该按照字典序输出所有对手组合。也就是说，这对组合的第一个名字的字典序应该小于第二个；如果两个组合中第一个名字不一样，则第一个名字字典序小的先输出；如果两个组合的第一个名字一样但第二个名字不同，则第二个名字字典序小的先输出。

## 输入格式

第一行输入一个正整数 $N$，表示学生个数。

第二行开始，往下 $N$ 行，对于每一行首先先输入一个字符串表示学生姓名，再输入三个自然数表示语文、数学、英语的成绩。均用空格相隔。

## 输出格式

输出若干行，每行两个以空格隔开的字符串，表示一组旗鼓相当的对手。注意题目描述中的输出格式。

## 样例 #1

### 样例输入 #1

```
3
fafa 90 90 90
lxl 95 85 90
senpai 100 80 91
```

### 样例输出 #1

```
fafa lxl
lxl senpai
```

## 提示

数据保证，$1 \leq N \leq 1000$，姓名为长度不超过 $8$ 的字符串，语文、数学、英语成绩均为不超过 $150$ 的自然数。",函数与结构体,,,,,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  Score[] ss = new Score[n];
  for (int i = 0; i < n; i++) {
   String str = sc.next();
   int s1 = sc.nextInt();
   int s2 = sc.nextInt();
   int s3 = sc.nextInt();
   ss[i] = new Score(str, s1, s2, s3);
  }
  for (int i = 0; i < n - 1; i++) {
   for (int k = i + 1; k < n; k++) {
    ss[i].compare(ss[k]);
   }
  }
 
 }
}
 
class Score {
 private String name;
 private int s1, s2, s3, sum;
 
 public Score(String name, int s1, int s2, int s3) {
  this.s1 = s1;
  this.s2 = s2;
  this.s3 = s3;
  this.name = name;
  this.sum = s1 + s2 + s3;
 }
 
 public void compare(Score o) {
  if (Math.abs(this.sum - o.sum) <= 10) {
   if (Math.abs(this.s1 - o.s1) <= 5 && Math.abs(this.s2 - o.s2) <= 5 && Math.abs(this.s3 - o.s3) <= 5)
    System.out.println(this.name + "" "" + o.name);
  }
 }
 
}",1
,"# 评等级

## 题目描述

现有 $N$ 名同学，每名同学需要设计一个结构体记录以下信息：学号、学业成绩和素质拓展成绩、综合分数（实数）。每行读入同学的学号、学业成绩和素质拓展成绩，并且计算综合分数（分别按照 $70\%$ 和 $30\%$ 权重累加），存入结构体中。还需要在结构体中定义一个成员函数，返回该结构体对象的学业成绩和素质拓展成绩的总分。

然后需要设计一个函数，其参数是一个学生结构体对象，判断该学生是否“优秀”。优秀的定义是学业和素质拓展成绩总分**大于** $140$ 分，且综合分数**不小于** $80$ 分。

> 当然通过本题很容易啦，本题只是为了帮助你训练结构体的使用方法。

本题存在精度误差问题，请将 `a * 0.7 + b * 0.3` 与 80 比较 转化为 `a * 7 + b * 3` 与 800 比较。

## 输入格式

第一行一个整数 $N$。

接下来 $N$ 行，每行 $3$ 个整数，依次代表学号、学业成绩和素质拓展成绩。

## 输出格式

$N$ 行，如果第 $i$ 名学生是优秀的，输出 `Excellent`，否则输出 `Not excellent`。

## 样例 #1

### 样例输入 #1

```
4
1223 95 59
1224 50 7
1473 32 45
1556 86 99
```

### 样例输出 #1

```
Excellent
Not excellent
Not excellent
Excellent
```

## 提示

数据保证，$1 \le N\le 1000$，学号为不超过 $100000$ 的正整数，学业成绩和素质拓展成绩为 $0 \sim 100$ 之间的正整数。",函数与结构体,,,,,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  Score[] ss = new Score[n];
  for (int i = 0; i < n; i++) {
   sc.nextInt();
   int s2 = sc.nextInt();
   int s3 = sc.nextInt();
   ss[i] = new Score(s2, s3);
   compare(ss[i]);
  }
 
 }
 
 public static void compare(Score a) {
  if (a.syn() >= 800 && a.sum > 140)
   System.out.println(""Excellent"");
  else
   System.out.println(""Not excellent"");
 
 }
}
 
class Score {
  int s2, s3, sum;
 
 public Score(int s2, int s3) {
  this.s2 = s2;
  this.s3 = s3;
  this.sum = s2 + s3;
 }
 
 public int syn() {
  return this.s2 * 7 + this.s3 * 3;
 }
 
}",1
,"# 质因数分解

## 题目描述

已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。

## 输入格式

输入一个正整数 $n$。

## 输出格式

输出一个正整数 $p$，即较大的那个质数。

## 样例 #1

### 样例输入 #1

```
21
```

### 样例输出 #1

```
7
```

## 提示

$1 \le n\le 2\times 10^9$

NOIP 2012 普及组 第一题","函数与结构体,质数",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int a = sc.nextInt();
            int b = 2;
            for(int i = 1;2*i+1<Math.sqrt(a);i++){
                if(a%b==0){
                    break;
                }
                b = 2*i+1;
            }
            System.out.println(Math.max(b, a / b));
        }
}",1
,"# 哥德巴赫猜想

## 题目描述

输入一个偶数 $N$，验证 $4\sim N$ 所有偶数是否符合哥德巴赫猜想：任一大于 $2$ 的偶数都可写成两个质数之和。如果一个数不止一种分法，则输出第一个加数相比其他分法最小的方案。例如 $10$，$10=3+7=5+5$，则 $10=5+5$ 是错误答案。

## 输入格式

第一行输入一个正偶数 $N$

## 输出格式

输出 $\dfrac{N-2}{2}$ 行。对于第 $i$ 行：

首先先输出正偶数 $2i+2$，然后输出等号，再输出加和为 $2i+2$ 且第一个加数最小的两个质数，以加号隔开。

## 样例 #1

### 样例输入 #1

```
10
```

### 样例输出 #1

```
4=2+2
6=3+3
8=3+5
10=3+7
```

## 提示

数据保证，$ 4 \leq N\leq10000$。",函数与结构体，搜索，质数,,,,,"import java.util.*;
 
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int b = sc.nextInt();
        for(int i = 4;i<=b;i+=2){
            for(int k = 2;k<=i/2;k++){
                if(Ispri(k) &&Ispri(i-k) ){
                        System.out.printf(""%d=%d+%d\n"",i,k,i-k);
                        break;
                }
            }
        }
    }
    public static boolean Ispri(int a){
 
            for (int i = 2; i <= Math.sqrt(a); i++) {
                if (a % i == 0)
                    return false;
            }
        return true;
    }
}",0
,"# 回文质数 

## 题目描述

因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。

写一个程序来找出范围 $[a,b] (5 \le a < b \le 100,000,000)$（一亿）间的所有回文质数。

## 输入格式

第一行输入两个正整数 $a$ 和 $b$。

## 输出格式

输出一个回文质数的列表，一行一个。

## 样例 #1

### 样例输入 #1

```
5 500
```

### 样例输出 #1

```
5
7
11
101
131
151
181
191
313
353
373
383
```

## 提示

Hint 1: Generate the palindromes and see if they are prime.

提示 1: 找出所有的回文数再判断它们是不是质数（素数）.


Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.

提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。


题目翻译来自NOCOW。

USACO Training Section 1.5


产生长度为 $5$ 的回文数：

```cpp
for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
     for (d2 = 0; d2 <= 9; d2++) {
         for (d3 = 0; d3 <= 9; d3++) {
           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)
         }
     }
 }

```",函数与结构体,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int a = sc.nextInt();
            int b = sc.nextInt();
            int pa = 0;
            String sb = String.valueOf(b);
            int bl = sb.length();
            for(int i = 1;i<=bl;i++) {
                switch (i) {
                    case 1:
                        //质数一定不是二的倍数，简化掉以2的倍数结尾的数
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            pa = a1;
                            if (pa >= a && pa <= b && zhishu(pa))
                                System.out.println(pa);
                        }
                        break;
                    case 2:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            pa = a1 * 10 + a1;
                            if (pa >= a && pa <= b && zhishu(pa))
                                System.out.println(pa);
                        }
                        break;
                    case 3:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                pa = a1 * 100 + b1 * 10 + a1;
                                if (pa >= a && pa <= b && zhishu(pa))
                                    System.out.println(pa);
                            }
                        }
                        break;
//                    case 4:
//                        for (int a1 = 1; a1 <= 9; a1 += 2) {
//                            for (int b1 = 0; b1 <= 9; b1++) {
//                                pa = a1 * 1000 + b1 * 100 + b1 * 10 + a1;
//                                if (pa >= a && pa <= b && zhishu(pa))
//                                    System.out.println(pa);
//                            }
//                        }
//                        break;
                    //偶数次回文数没有质数，除11外
                    case 5:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    pa = a1 * 10000 + b1 * 1000 + c1 * 100 + b1 * 10 + a1;
                                    if (pa >= a && pa <= b && zhishu(pa))
                                        System.out.println(pa);
                                }
                            }
                        }
                        break;
                    case 6:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    pa = a1 * 100000 + b1 * 10000 + c1 * 1000 + c1*100+ b1 * 10 + a1;
                                    if (pa >= a && pa <= b && zhishu(pa))
                                        System.out.println(pa);
                                }
                            }
                        }
                        break;
                    case 7:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    for(int d1 = 0;d1<=9;d1++) {
                                        pa = a1 * 1000000 + b1 * 100000 + c1 * 10000+ d1*1000+ c1 * 100 + b1 * 10 + a1;
                                        if (pa >= a && pa <= b && zhishu(pa))
                                            System.out.println(pa);
                                    }
                                }
                            }
                        }
                        break;
                    case 8:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    for(int d1 = 0;d1<=9;d1++) {
                                        pa = a1 * 10000000 + b1 * 1000000 + c1 * 100000+ d1*10000 +d1*1000+ c1 * 100 + b1 * 10 + a1;
                                        if (pa >= a && pa <= b && zhishu(pa))
                                            System.out.println(pa);
                                    }
                                }
                            }
                        }
                        break;
//                    case 9:
//                        for (int a1 = 1; a1 <= 9; a1 += 2) {
//                            for (int b1 = 0; b1 <= 9; b1++) {
//                                for (int c1 = 0; c1 <= 9; c1++) {
//                                    for(int d1 = 0;d1<=9;d1++) {
//                                        for(int e1 = 0;e1<=9;e1++) {
//                                            pa = a1 * 100000000 + b1 * 10000000 + c1 * 1000000 + d1 * 100000+e1*10000 + d1 * 1000 + c1 * 100 + b1 * 10 + a1;
//                                            if (pa >= a && pa <= b && zhishu(pa))
//                                                System.out.println(pa);
//                                        }
//                                    }
//                                }
//                            }
//                        }
//                        break;
                    //一亿并不是回文数，也不是质数
                }
            }
        }
        static boolean zhishu(int a){
            if(a<5)
                return false;
            for(int b = 2;b <= Math.sqrt(a);b++){
                if( a % b == 0)
                    return false;
            }
            return true;
    }
}",1
,"# 集合求和

## 题目描述

给定一个集合 $s$（集合元素数量 $\le 30$），求出此集合所有子集元素之和。

## 输入格式

集合中的元素（元素 $\le 1000$）

## 输出格式

$s$ 所有子集元素之和。

## 样例 #1

### 样例输入 #1

```
2 3
```

### 样例输出 #1

```
10
```

## 提示

**【样例解释】**

子集为：$\varnothing, \{ 2 \}, \{ 3 \}, \{ 2, 3 \}$，和为 $2 + 3 + 2 + 3 = 10$。

----

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le \lvert s \rvert \le 30$，$1 \le s_i \le 1000$，$s$ 所有子集元素之和 $\le {10}^{18}$。",函数与结构体，排列组合,,,,,"import java.util.*;
 
 
public class Main {
    public static void main(String[] args) {
        long sum = 0;
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String[] ss = s.split("" "");
        for(int i = 0;i<ss.length;i++){
            int num = Integer.parseInt(ss[i]);
            sum += num * Math.pow(2,ss.length-1);
        }
        System.out.println(sum);
    }
}",1
,"# 猴子吃桃

## 题目描述

一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；接下来的每一天它都会吃剩余的桃子的一半外加一个。第 $n$ 天早上起来一看，只剩下 $1$ 个桃子了。请问小猴买了几个桃子？

## 输入格式

输入一个正整数 $n$，表示天数。

## 输出格式

输出小猴买了多少个桃子。

## 样例 #1

### 样例输入 #1

```
4
```

### 样例输出 #1

```
22
```

## 提示

数据保证，$1\le n\le20$。",函数与结构体,,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc  = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(Monkey(n,1));
    }
    public static  int Monkey(int a,int b){
        b = (b+1)*2;
        if(a==1)
            return 1;
        if(a==2)
            return b;
        return Monkey(--a,b);
    }
}",0
,"# 培训

## 题目描述

某培训机构的学员有如下信息：

- 姓名（字符串）
- 年龄（周岁，整数）
- 去年 NOIP 成绩（整数，且保证是 $5$ 的倍数）

经过为期一年的培训，所有同学的成绩都有所提高，提升了 $20\%$（当然 NOIP 满分是 $600$ 分，不能超过这个得分）。

输入学员信息，请设计一个结构体储存这些学生信息，并设计一个函数模拟培训过程，其参数是这样的结构体类型，返回同样的结构体类型，并输出学员信息。

## 输入格式

第一行输入一个正整数 $n$，表示学员个数。

第二行开始往下 $n$ 行。每行首先是一个字符串表示学员姓名，再是一个整数表示学员年龄，再是一个整数为去年 NOIP 成绩。

## 输出格式

输出 $n$ 行，每行首先输出一个字符串表示学生姓名，再往后两个整数，表示经过一年的培训后学员的年龄和他们今年的 NOIP 成绩。以空格隔开。

## 样例 #1

### 样例输入 #1

```
3
kkksc03 24 0
chen_zhe 14 400
nzhtl1477 18 590
```

### 样例输出 #1

```
kkksc03 25 0
chen_zhe 15 480
nzhtl1477 19 600
```

## 提示

数据保证，$1 \leq n \leq 5$。年龄为 $0 \sim 100$（含 $0$ 与 $100$）的整数。成绩为 $0 \sim 600$（含 $0$ 与 $600$）的 $5$ 的整倍数。",函数与结构体,,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc  = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        String[][] str = new String[n][3];
        for(int i = 0; i<n;i++){
            String s = sc.nextLine();
            str[i] = s.split("" "");
            str[i][1] = String.valueOf(Integer.parseInt(str[i][1])+1);
            str[i][2] = String.valueOf(Math.min(Integer.parseInt(str[i][2]) * 12 / 10, 600));
            String ss = Arrays.toString(str[i]);
            //eg：ss中的数据如下 [kkksc03, 25, 0] 
            ss = ss.replaceAll("", "","" ""); //去掉逗号
            System.out.println(ss.substring(1,ss.length()-1));//截去中括号
        }
    }
}",0
,"# 自动修正

## 题目描述

大家都知道一些办公软件有自动将字母转换为大写的功能。输入一个长度不超过 $100$ 且不包括空格的字符串。要求将该字符串中的所有小写字母变成大写字母并输出。

## 输入格式

输入一行，一个字符串。

## 输出格式

输出一个字符串，即将原字符串中的所有小写字母转化为大写字母。

## 样例 #1

### 样例输入 #1

```
Luogu4!
```

### 样例输出 #1

```
LUOGU4!
```",字符串,,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str  = sc.nextLine();
        System.out.println(str.toUpperCase());
    }
}",0
,"# 小书童――凯撒密码

## 题目背景

某Xm迷上了 “小书童”，有一天登陆时忘记密码了（他没绑定邮箱 or 手机），于是便把问题抛给了神哪恪

## 题目描述

Xm虽然忘记密码，但他还记得密码是由一个字符串组成。密码是由原文字符串（由不超过 50 个小写字母组成）中每个字母向后移动 $n$ 位形成的。`z` 的下一个字母是 `a`，如此循环。他现在找到了移动前的原文字符串及 $n$，请你求出密码。

## 输入格式

第一行：$n$。第二行：未移动前的一串字母。

## 输出格式

一行，是此Xm的密码。

## 样例 #1

### 样例输入 #1

```
1
qwe
```

### 样例输出 #1

```
rxf
```

## 提示

字符串长度 $\le 50$，$1 \leq n \leq 26$。","字符串,模拟",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        String str = sc.nextLine();
        for(int i = 0;i<str.length();i++){
            int a = (int)str.charAt(i)+n;
            while(a>'z')
                a = a-'z'-1+'a';
            System.out.print((char)a);
        }
    }
}",0
,"# 笨小猴

## 题目描述

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！

这种方法的具体描述如下：假设 $\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\text{maxn}-\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。

## 输入格式

一个单词，其中只可能出现小写字母，并且长度小于 $100$。

## 输出格式

共两行，第一行是一个字符串，假设输入的的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；

第二行是一个整数，如果输入单词是 `Lucky Word`，输出 $\text{maxn}-\text{minn}$ 的值，否则输出 $0$。

## 样例 #1

### 样例输入 #1

```
error
```

### 样例输出 #1

```
Lucky Word
2
```

## 样例 #2

### 样例输入 #2

```
olympic
```

### 样例输出 #2

```
No Answer
0
```

## 提示

【输入输出样例 1 解释】

单词 `error` 中出现最多的字母 $\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。

【输入输出样例 2 解释】

单词 `olympic` 中出现最多的字母 $\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。

（本处原题面错误已经修正）

noip2008 提高第一题","字符串,素数,质数",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] arr = new int[26];
        int max = 1;
        int min = 100;
        boolean ansb = false;
        String str = sc.nextLine();
        for(int i = 0;i<str.length();i++){
            int a = str.charAt(i)-'a';
            arr[a]++;
        }
        for(int i = 0 ;i<26;i++){
            if(arr[i]!=0) {
                if (arr[i] < min)
                    min = arr[i];
                if (arr[i] > max)
                    max = arr[i];
            }
        }
        int ans = max- min;
        int[] pri = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};//打表
        for (int j : pri) {
            if (ans == j) {
                ansb = true;
                break;
            }
        }
        if(ansb) {
            System.out.println(""Lucky Word"");
            System.out.println(ans);
        }
 
        else{
            System.out.println(""No Answer"");
            System.out.println(0);
        }
    }
}",1
,"# 口算练习题

## 题目描述

王老师正在教简单算术运算。细心的王老师收集了 $i$ 道学生经常做错的口算题，并且想整理编写成一份练习。 编排这些题目是一件繁琐的事情，为此他想用计算机程序来提高工作效率。王老师希望尽量减少输入的工作量，比如 $\texttt{5+8}$ 的算式最好只要输入 $\texttt 5$ 和 $\texttt 8$，输出的结果要尽量详细以方便后期排版的使用，比如对于上述输入进行处理后输出 $\texttt{5+8=13}$ 以及该算式的总长度 $6$。王老师把这个光荣的任务交给你，请你帮他编程实现以上功能。

## 输入格式

第一行一个整数 $i$。

接着的 $i$ 行为需要输入的算式，每行可能有三个数据或两个数据。

若该行为三个数据则第一个数据表示运算类型，$\texttt a$ 表示加法运算，$\texttt b$ 表示减法运算，$\texttt c$ 表示乘法运算，接着的两个数据表示参加运算的运算数。

若该行为两个数据，则表示本题的运算类型与上一题的运算类型相同，而这两个数据为运算数。

## 输出格式

输出 $2\times i$ 行。对于每个输入的算式，输出完整的运算式及结果，第二行输出该运算式的总长度。

## 样例 #1

### 样例输入 #1

```
4
a 64 46
275 125
c 11 99
b 46 64
```

### 样例输出 #1

```
64+46=110
9
275+125=400
11
11*99=1089
10
46-64=-18
9
```

## 提示

### 【数据规模与约定】

对于 $50\%$ 的数据，输入的算式都有三个数据，第一个算式一定有三个数据。

对于所有数据，$0<i\leq 50$，运算数为非负整数且小于 $10000$。","字符串,模拟",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int c;
        char o = 'a';
        int ans = 0;
        String equ = """";
        for(int i = 0;i<a;i++) {
            int b = 0;
            String str = sc.next();
            if((int)str.charAt(0)-'a'>= 0) {
                o = str.charAt(0);
                b = sc.nextInt();
            }
            else{
                for(int m = 0;m<str.length();m++){
                    b = Integer.parseInt(str);
                }
            }
            c = sc.nextInt();
            switch(o){
                case 'a':
                    ans = b+c;
                    equ = b+""+""+c+""=""+ans;
                    System.out.println(equ);
                    System.out.println(equ.length());
                    break;
                case 'b':
                    ans = b-c;
                    equ = b+""-""+c+""=""+ans;
                    System.out.println(equ);
                    System.out.println(equ.length());
                    break;
                case 'c':
                    ans = b*c;
                    equ = b+""*""+c+""=""+ans;
                    System.out.println(equ);
                    System.out.println(equ.length());
                    break;
            }
        }
    }
}",1
,"# 标题统计

## 题目背景

NOIP2018 普及组 T1

## 题目描述

凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？ 注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字符数时，空格和换行符不计算在内。

## 输入格式

输入文件只有一行，一个字符串 $s$。

## 输出格式

输出文件只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。

## 样例 #1

### 样例输入 #1

```
234
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2

```
Ca 45
```

### 样例输出 #2

```
4
```

## 提示

**样例 1 说明**   

标题中共有 3 个字符，这 3 个字符都是数字字符。   

**样例 2 说明**

标题中共有 $ 5$ 个字符，包括 $1$ 个大写英文字母， $1$ 个小写英文字母和 $2$ 个数字字符， 还有 $1$ 个空格。由于空格不计入结果中，故标题的有效字符数为 $4$ 个。 

**数据规模与约定**

规定 $|s|$ 表示字符串 $s$ 的长度（即字符串中的字符和空格数）。    
对于 $40\%$ 的数据，$1 ≤ |s| ≤ 5$，保证输入为数字字符及行末换行符。   
对于 $80\%$ 的数据，$1 ≤ |s| ≤ 5$，输入只可能包含大、小写英文字母、数字字符及行末换行符。   
对于 $100\%$ 的数据，$1 ≤ |s| ≤ 5$，输入可能包含大、小写英文字母、数字字符、空格和行末换行符。","字符串,模拟",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int a = 0;
        for(int i = 0;i<str.length();i++){
            if((int)str.charAt(i) != 32)
                a++;
        }
        System.out.println(a);
    }
}",0
,"# 文字处理软件

## 题目描述

你需要开发一款文字处理软件。最开始时输入一个字符串作为初始文档。可以认为文档开头是第 $0$ 个字符。需要支持以下操作：

- `1 str`：后接插入，在文档后面插入字符串 $\texttt{str}$，并输出文档的字符串；
- `2 a b`：截取文档部分，只保留文档中从第 $a$ 个字符起 $b$ 个字符，并输出文档的字符串；
- `3 a str`：插入片段，在文档中第 $a$ 个字符前面插入字符串 $\texttt{str}$，并输出文档的字符串；
- `4 str`：查找子串，查找字符串 $\texttt{str}$ 在文档中最先的位置并输出；如果找不到输出 $-1$。

为了简化问题，规定初始的文档和每次操作中的 $\texttt{str}$ 都不含有空格或换行。最多会有 $q$ 次操作。

## 输入格式

第一行输入一个正整数 $q$，表示操作次数。

第二行输入一个字符串 $\texttt{str}$，表示最开始的字符串。

第三行开始，往下 $q$ 行，每行表示一个操作，操作如题目描述所示。

## 输出格式

一共输出 $q$ 行。

对于每个操作 $1,2,3$，根据操作的要求输出一个字符串。

对于操作 $4$，根据操作的要求输出一个整数。

## 样例 #1

### 样例输入 #1

```
4
ILove
1 Luogu
2 5 5
3 3 guGugu
4 gu
```

### 样例输出 #1

```
ILoveLuogu
Luogu
LuoguGugugu
3
```

## 提示

数据保证，$1 \leq q\le 100$，开始的字符串长度 $\leq 100$。",字符串,,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = 0;
        int b = 0;
        String s1 = """";
        int q = sc.nextInt();
        String str = sc.next();
        for(int i = 0 ;i < q;i++){
            int o = sc.nextInt();
            switch (o){
                case 1:
                    s1 = sc.next();
                    str = str+s1;
                    System.out.println(str);
                    break;
                case 2:
                    a = sc.nextInt();
                    b = sc.nextInt();
                    str = str.substring(a,a+b);
                    System.out.println(str);
                    break;
                case 3:
                    a = sc.nextInt();
                    s1 = sc.next();
                    StringBuilder sb = new StringBuilder(str);
                    sb.insert(a,s1);
                    str = sb.toString();
                    System.out.println(str);
                    break;
                case 4:
                    s1 = sc.next();
                    System.out.println(str.indexOf(s1));
            }
        }
    }
}",0
,"# 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。

## 输入格式

共 $2$ 行。

第 $1$ 行为一个字符串，其中只含字母，表示给定单词；

第 $2$ 行为一个字符串，其中只可能包含字母和空格，表示给定的文章。

## 输出格式

一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从 $0$ 开始）；如果单词在文章中没有出现，则直接输出一个整数 $-1$。

注意：空格占一个字母位

## 样例 #1

### 样例输入 #1

```
To
to be or not to be is a question
```

### 样例输出 #1

```
2 0
```

## 样例 #2

### 样例输入 #2

```
to
Did the Ottoman Empire lose its power at that time
```

### 样例输出 #2

```
-1
```

## 提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题","字符串,模拟",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str1 = sc.nextLine().toUpperCase();
        String str2 = sc.nextLine().toUpperCase();
        boolean t = true;
        int a = str2.indexOf(str1);
        int b = -1;
        int cont = 0;
        while(a != -1){
            if((a==0 || str2.charAt(a-1)==' ') && (a+str1.length() == str2.length() || str2.charAt(a+str1.length()) == ' ')) {
                cont++;
                if(t){
                    b = a;
                    t = false;
                }
            }
            a = str2.indexOf(str1,a+str1.length());
        }
        if(cont == 0)
            System.out.println(-1);
        else
            System.out.printf(""%d %d"",cont,b);
    }
}",1
,"# 手机

## 题目描述

一般的手机的键盘是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/yq2orii6.png)

要按出英文字母就必须要按数字键多下。例如要按出 $\tt x$ 就得按 $9$ 两下，第一下会出 $\tt w$，而第二下会把 $\tt w$ 变成 $\tt x$。$0$ 键按一下会出一个空格。

你的任务是读取若干句只包含英文小写字母和空格的句子，求出要在手机上打出这个句子至少需要按多少下键盘。

## 输入格式

一行句子，只包含英文小写字母和空格，且不超过 200 个字符。

## 输出格式

一行一个整数，表示按键盘的总次数。

## 样例 #1

### 样例输入 #1

```
i have a dream
```

### 样例输出 #1

```
23
```

## 提示

NOI 导刊 2010 普及（10）","字符串,模拟,枚举",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s1 = ""adgjmptw "";
        String s2 = ""behknqux"";
        String s3 = ""cfilorvy"";
        String s4 = ""sz"";
        int ans = 0;
        String str = sc.nextLine();
        for(int i = 0;i<str.length();i++){
                if(s1.indexOf(str.charAt(i)) != -1)
                    ans +=1;
                if(s2.indexOf(str.charAt(i)) != -1)
                    ans +=2;
                if(s3.indexOf(str.charAt(i)) != -1)
                    ans +=3;
                if(s4.indexOf(str.charAt(i)) != -1)
                    ans +=4;
        }
        System.out.println(ans);
    }
}",0
,"# 单词覆盖还原

## 题目描述

我有一个长度为 $l$ 的字符串，最开始时，这个字符串由 $l$ 个句号（`.`）组成。

我在这个字符串中，将多次把 `boy` 或者 `girl` 两单词，依次贴到这个字符串中。

后贴上单词，会覆盖之前贴上的单词，或者覆盖句号。最终，每个单词至少有一个字符没有被覆盖。

请问，一共贴有几个 `boy` 几个 `girl`？

## 输入格式

一行被反复贴有 `boy` 和 `girl` 两单词的字符串。

## 输出格式

两行，两个整数。第一行为 `boy` 的个数，第二行为 `girl` 的个数。

## 样例 #1

### 样例输入 #1

```
......boyogirlyy......girl.......
```

### 样例输出 #1

```
4
2
```

## 提示

数据保证，$3\le l\le255$，字符串仅仅包含如下字符：$\texttt{.bgilory}$。","字符串,模拟",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int B = 0;
        int G = 0;
        for(int i = 0;i<str.length()-2;i++)
            if(str.charAt(i) == 'b' || str.charAt(i+1) == 'o' || str.charAt(i+2) == 'y')
                B++;
        for(int i = 0;i<str.length()-3;i++)
            if(str.charAt(i) == 'g' || str.charAt(i+1) == 'i' ||str.charAt(i+2) == 'r' ||str.charAt(i+3) == 'l' )
                G++;
        System.out.println(B);
        System.out.println(G);
    }
}",0
,"# 数字反转

## 题目背景

**以下为原题面，仅供参考:**

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 $0$（除非小数部分除了 $0$ 没有别的数，那么只保留1个 $0$）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 $0$），本次没有负数。

## 题目描述

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。

- 整数反转是将所有数位对调。

- 小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。

- 分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。

- 百分数的分子一定是整数，百分数只改变数字部分。

## 输入格式

一个实数 $s$

## 输出格式

一个实数，即 $s$ 的反转数

## 样例 #1

### 样例输入 #1

```
5087462
```

### 样例输出 #1

```
2647805
```

## 样例 #2

### 样例输入 #2

```
600.084
```

### 样例输出 #2

```
6.48
```

## 样例 #3

### 样例输入 #3

```
700/27
```

### 样例输出 #3

```
7/72
```

## 样例 #4

### 样例输入 #4

```
8670%
```

### 样例输出 #4

```
768%
```

## 提示

**【数据范围】**

- 对于 $25\%$ 的数据，$s$ 是整数，不大于 $20$ 位；
- 对于 $25\%$ 的数据，$s$ 是小数，整数部分和小数部分均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是分数，分子和分母均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是百分数，分子不大于 $19$ 位。

**【数据保证】**

- 对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。

- 对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 $0$（小数部分除了 $0$ 没有别的数，那么只保留 $1$ 个 $0$。若反转之后末尾数字出现 $0$，请省略多余的 $0$）

- 对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为 $0$。与整数翻转相关规定见上。

- 对于百分数翻转而言，见与整数翻转相关内容。

数据不存在负数。","字符串,模拟",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String o = ""/.%"";
        String str = sc.nextLine();
        String s1 = """";
        String s2 = """";
        String a = """";
        boolean t = true;
        for(int i  = 0;i < str.length();i++){
            if(!o.contains(str.charAt(i)+"""") && t) {
                s1 = str.charAt(i) + s1;
            }
            else {
                t = false;
                a = a+str.charAt(i);
                s2 = str.charAt(i) + s2;
            }
        }
        s1 = s1.replaceAll(""^(0+)"","""");
        s1 = s1.length() == 0?""0"":s1;
        if(a.length()>1) {
            s2 = s2.substring(0, s2.length() - 1);
            if(a.charAt(0) == '.')
                s2 = s2.replaceAll(""(0+)$"","""");
            else
                s2 = s2.replaceAll(""^(0+)"","""");
            s2 = s2.length() == 0?""0"":s2;
            System.out.println(s1+a.charAt(0)+s2);
        }
        else
            System.out.println(s1+a);
    }
}",1
,"# 斯诺登的密码

## 题目背景

根据斯诺登事件出的一道水题

## 题目描述

2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为 FBI 的间谍早已获悉他的具体位置――但这不是最重要的――最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。

丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：`Obama is a two five zero.`（以 `.` 结束输出，只有 $6$ 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈B骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈B鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现――程序被粉碎了！飞机抵达华盛顿只剩 $5$ 分钟，你必须在这 $5$ 分钟内编写（杜撰）一个程序，免受上司的 $10000000000 \bmod 10$ 大板。破译密码的步骤如下：

（1）找出句子中所有用英文表示的数字 $(\leq 20)$，列举在下：

正规：`one two three four five six seven eight nine ten eleven twelve`
           `thirteen fourteen fifteen sixteen seventeen eighteen nineteen             twenty`

非正规：`a both another first second third`。为避免造成歧义，`another` 算作 $1$ 处理。

（2）将这些数字平方后对 $100$ 取模，如 $00,05,11,19,86,99$。

（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 $0$，就去 $0$。

（4）找出所有排列方法中最小的一个数，即为密码。

// 数据已经修正 By absi2011 如果还有问题请联系我

## 输入格式

一个含有 $6$ 个单词的句子。

## 输出格式

一个整型变量（密码）。如果没有符合要求的数字出现，则输出 $0$。

## 样例 #1

### 样例输入 #1

```
Black Obama is two five zero .
```

### 样例输出 #1

```
425
```","字符串,模拟,排序",,,,,"import java.util.*;
import java.util.stream.IntStream;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s1 = ""a+one+anther+first two+both+second three+third four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty"";
        String s2 = sc.nextLine();
        String s3 = """";
        int[] arr = new int[6];
        String[] sp2 = s2.split("" "");
        String[] sp1 = s1.split("" "");
        for(int i = 0;i<6;i++){
            for(int m = 0;m<sp1.length;m++){
                if(sp1[m].contains(sp2[i])) {
                    arr[i] = m + 1;
                    break;
                }
            }
        }
        for(int i = 0;i<arr.length;i++)
            arr[i] = arr[i]*arr[i] % 100;
        Arrays.sort(arr);
        for(int i = 0;i<arr.length;i++) {
            if(arr[i]<10)
                s3 = s3 + '0';
            s3 = s3 + arr[i];
        }
        s3 = s3.replaceAll(""^(0+)"","""");
        if(s3.length() == 0)
            s3 = ""0"";
        System.out.println(s3);
    }
}",1
,"# 你的飞碟在这儿 Your Ride Is Here

## 题目描述

众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。


小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 $\texttt A$ 是 $1$，$\texttt Z$ 是 $26$。例如，$\texttt{USACO}$ 小组就是 $21 \times 19 \times 1 \times 3 \times 15=17955$。如果小组的数字 $\bmod 47$ 等于彗星的数字 $\bmod 47$,你就得告诉这个小组需要准备好被带走！（记住“$a \bmod b$”是 $a$ 除以 $b$ 的余数，例如 $34 \bmod 10$ 等于 $4$）


写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 `GO`，否则输出 `STAY`。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 $6$ 个字母）。

## 输入格式

第1行：一个长度为 $1$ 到 $6$ 的大写字母串，表示彗星的名字。

第2行：一个长度为 $1$ 到 $6$ 的大写字母串，表示队伍的名字。

## 输出格式

## 样例 #1

### 样例输入 #1

```
COMETQ
HVNGAT
```

### 样例输出 #1

```
GO
```

## 样例 #2

### 样例输入 #2

```
ABSTAR
USACO
```

### 样例输出 #2

```
STAY
```

## 提示

题目翻译来自 NOCOW。

USACO Training Section 1.1",字符串,,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s1 = sc.nextLine();
        String s2 = sc.nextLine();
        int a = 1;
        int b = 1;
        for(int i = 0; i<Math.max(s1.length(),s2.length());i++) {
            if (i < s1.length())
                a *= (s1.charAt(i) - 'A' + 1);
            if (i < s2.length())
                b *= (s2.charAt(i) - 'A' + 1);
        }
        if(b%47 == a%47)
            System.out.println(""GO"");
        else
            System.out.println(""STAY"");
    }
}",0
,"# 语句解析

## 题目背景

木有背景……

## 题目描述

一串长度不超过 $255$ 的 PASCAL 语言代码，只有 $a,b,c$ 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，每条赋值语句的格式是 `[变量]:=[变量或一位整数];`。未赋值的变量值为 $0$ 输出 $a,b,c$ 的值。

## 输入格式

一串符合语法的 PASCAL 语言，只有 $a,b,c$ 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，未赋值的变量值为 $0$。

## 输出格式

输出 $a,b,c$ 最终的值。

## 样例 #1

### 样例输入 #1

```
a:=3;b:=4;c:=5;
```

### 样例输出 #1

```
3 4 5
```

## 提示

输入的 PASCAL 语言长度不超过 $255$。","字符串,模拟",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int[] arr = new int[3];
        for(int i = 0;i<str.length()/5;i++){
            int a = str.charAt(i*5) - 'a';
            int b = str.charAt(3+i*5);
            arr[a] = b<='9'?b-'0':arr[b-'a'];
        }
        System.out.printf(""%d %d %d"",arr[0],arr[1],arr[2]);
    }
}",0
,"# 垂直柱状图

## 题目描述

写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过 $100$ 个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。

## 输入格式

四行字符，由大写字母组成，每行不超过 $100$ 个字符

## 输出格式

由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。

## 样例 #1

### 样例输入 #1

```
THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.
THIS IS AN EXAMPLE TO TEST FOR YOUR
HISTOGRAM PROGRAM.
HELLO!
```

### 样例输出 #1

```
*
                            *
        *                   *
        *                   *     *   *
        *                   *     *   *
*       *     *             *     *   *
*       *     * *     * *   *     * * *
*       *   * * *     * *   * *   * * * *
*     * * * * * *     * * * * *   * * * *     * *
* * * * * * * * * * * * * * * * * * * * * * * * * *
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
```

## 提示

每行输出后面不允许出现多余的空格。","字符串,模拟",,,,,"import java.util.*;
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s1 = sc.nextLine();
        String s2 = sc.nextLine();
        String s3 = sc.nextLine();
        String s4 = sc.nextLine();
        String s = s1+s2+s3+s4;
        int[] arr = new int[26];
        for(int i = 0;i<s.length();i++){
            if(s.charAt(i) - 'A'>=0)
                arr[s.charAt(i) - 'A']++;
        }
        int[] a1 = Arrays.copyOf(arr,26);
        Arrays.sort(a1);
        int a = a1[25];
        for(int i = 0;i<a1[25];i++){
            for(int k = 0;k<arr.length;k++){
                if(k != arr.length-1) {
                    if (arr[k] - a >= 0) {
                        System.out.print(""* "");
                    } else
                        System.out.print(""  "");
                }
                else {
                    if (arr[k] - a >= 0) {
                        System.out.print(""*"");
                    } else
                        System.out.print("" "");
                }
            }
            a--;
            System.out.println();
        }
        System.out.print(""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
    }
}",1
,"# 小果的键盘

## 题目背景

小果有一个只有两个键的键盘。

## 题目描述

一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 `VK` 这个字符串的时候，小果就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 `VK` 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 `VK`（只有当 `V` 和 `K` 正好相邻时，我们认为出现了 `VK`。）

## 输入格式

第一行给出一个数字 $n$，代表字符串的长度。

第二行给出一个字符串 $s$。

## 输出格式

第一行输出一个整数代表所求答案。

## 样例 #1

### 样例输入 #1

```
2
VK
```

### 样例输出 #1

```
1
```

## 样例 #2

### 样例输入 #2

```
2
VV
```

### 样例输出 #2

```
1
```

## 样例 #3

### 样例输入 #3

```
1
V
```

### 样例输出 #3

```
0
```

## 样例 #4

### 样例输入 #4

```
20
VKKKKKKKKKVVVVVVVVVK
```

### 样例输出 #4

```
3
```

## 样例 #5

### 样例输入 #5

```
4
KVKV
```

### 样例输出 #5

```
1
```

## 提示

对于 $100\%$ 的数据，$1\le n\le 100$。","字符串,模拟,搜索",,,,,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        String str = sc.next();
        int ad = str.indexOf(""VK"");
        while(ad != -1){
            ans++;
            ad = str.indexOf(""VK"",ad+2);
        }
        str = str.replaceAll(""VK"",""00"");
        if(str.contains(""VV"") || str.contains(""KK""))
            ans++;
        System.out.println(ans);
    }
}",0
,"# 小鱼比可爱

## 题目描述

人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度**可能一样**。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。

## 输入格式

第一行输入一个正整数 $n$，表示鱼的数目。

第二行内输入 $n$ 个正整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度 $a_i$。

## 输出格式

一行，输出 $n$ 个整数，用空格间隔，依次表示每只小鱼眼中有多少只鱼不如自己可爱。

## 样例 #1

### 样例输入 #1

```
6
4 3 0 5 1 2
```

### 样例输出 #1

```
0 0 0 3 1 2
```

## 提示

对于 $100\%$ 的数据，$1 \leq n\leq 100$，$0 \leq a_i \leq 10$。",数组,,,,,"import java.math.BigInteger;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc  = new Scanner(System.in);
  int n = sc.nextInt();
  int[] arr = new int[n];
  for(int i = 0;i<n;i++) {
   arr[i] = sc.nextInt();
   int b = 0;
   for(int a = 0;a<i;a++) {
    if(arr[i]>arr[a])
     b++;
   }
   System.out.printf(""%d "",b);
  }
 }
}",0
,"# 小鱼的数字游戏

## 题目描述

小鱼最近被要求参加一个数字游戏，要求它把看到的一串数字 $a_i$（长度不一定，以 $0$ 结束），记住了然后反着念出来（表示结束的数字 $0$ 就不要念出来了）。这对小鱼的那点记忆力来说实在是太难了，你也不想想小鱼的整个脑袋才多大，其中一部分还是好吃的肉！所以请你帮小鱼编程解决这个问题。

## 输入格式

一行内输入一串整数，以 $0$ 结束，以空格间隔。

## 输出格式

一行内倒着输出这一串整数，以空格间隔。

## 样例 #1

### 样例输入 #1

```
3 65 23 5 34 1 30 0
```

### 样例输出 #1

```
30 1 34 5 23 65 3
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $0 \leq a_i \leq 2^{31} - 1$，数字个数不超过 $100$。","数组,递归",,,,,"import java.util.ArrayList;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc  = new Scanner(System.in);
  ArrayList list  = new ArrayList();
  while(true){
   int a = sc.nextInt();
   if(a == 0)
    break;
   else
    list.add(a);
  }
  for(int i = 0;i<list.size() ;i++) {
   System.out.printf(""%d "",list.get(list.size() - i -1));
  }
 }
}",0
,"# 冰雹猜想

## 题目描述

给出一个正整数 $n$，然后对这个数字一直进行下面的操作：如果这个数字是奇数，那么将其乘 $3$ 再加 $1$，否则除以 $2$。经过若干次循环后，最终都会回到 $1$。经过验证很大的数字（$7\times10^{11}$）都可以按照这样的方式比变成 $1$，所以被称为“冰雹猜想”。例如当 $n$ 是 $20$，变化的过程是 $20\to 10\to 5\to 16\to 8\to 4\to 2\to 1$。

根据给定的数字，验证这个猜想，并从最后的 $1$ 开始，倒序输出整个变化序列。

## 输入格式

输入一个正整数 $n$。

## 输出格式

输出若干个由空格隔开的正整数，表示从最后的 $1$ 开始倒序的变化数列。

## 样例 #1

### 样例输入 #1

```
20
```

### 样例输出 #1

```
1 2 4 8 16 5 10 20
```

## 提示

数据保证，$1 \le n\le 100$。",数组,,,,,"import java.util.ArrayList;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc  = new Scanner(System.in);
  ArrayList list  = new ArrayList();
  int n = sc.nextInt();
  while(n != 1) {
   if(n %2 == 0) {
    list.add(n);
    n/=2;
   }
   else {
    list.add(n);
    n = n *3 + 1;
   }
  }
  list.add(1);
  for(int i = list.size();i>0;i--) {
   System.out.printf(""%d "",list.get(i - 1));
  }
 }
}",0
,"# 校门外的树

## 题目描述

某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\dots,l$，都种有一棵树。


由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

## 输入格式

第一行有两个整数，分别表示马路的长度 $l$ 和区域的数目 $m$。

接下来 $m$ 行，每行两个整数 $u, v$，表示一个区域的起始点和终止点的坐标。

## 输出格式

输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。

## 样例 #1

### 样例输入 #1

```
500 3
150 300
100 200
470 471
```

### 样例输出 #1

```
298
```

## 提示

**【数据范围】**

- 对于 $20\%$ 的数据，保证区域之间没有重合的部分。
- 对于 $100\%$ 的数据，保证 $1 \leq l \leq 10^4$，$1 \leq m \leq 100$，$0 \leq u \leq v \leq l$。

**【题目来源】**

NOIP 2005 普及组第二题","数组,模拟",,,,,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc  = new Scanner(System.in);
  int l = sc.nextInt();
  int s = sc.nextInt();
  int[] arr = new int[l+1];
  Arrays.fill(arr,1);
  for(int i = 0;i<s;i++) {
   int min = sc.nextInt();
   int max = sc.nextInt();
   for(int a = min;a<=max;a++) {
    arr[a] = 0;
   }
  }
  Arrays.sort(arr);
  int n = 0;
  for(int i = arr.length;i>0;i--) {
   if(arr[i-1] !=  0)
    n++;
   else
    break;
  }
  System.out.println(n);
 }
}",0
,"# 旗鼓相当的对手

## 题目描述

现有 $N$ 名同学参加了期末考试，并且获得了每名同学的信息：语文、数学、英语成绩（均为不超过 $150$ 的自然数）。如果某对学生 $\lang i,j\rang$ 的每一科成绩的分差都不大于 $5$，且总分分差不大于 $10$，那么这对学生就是“旗鼓相当的对手”。现在想知道这些同学中，有几对“旗鼓相当的对手”？同样一个人可能会和其他好几名同学结对。

## 输入格式

第一行一个正整数 $N$。

接下来 $N$ 行，每行三个整数，其中第 $i$ 行表示第 $i$ 名同学的语文、数学、英语成绩。最先读入的同学编号为 $1$。

## 输出格式

输出一个整数，表示“旗鼓相当的对手”的对数。

## 样例 #1

### 样例输入 #1

```
3
90 90 90
85 95 90
80 100 91
```

### 样例输出 #1

```
2
```

## 提示

数据保证，$2 \le N\le 1000$ 且每科成绩为不超过 $150$ 的自然数。",数组,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc  = new Scanner(System.in);
                int n = sc.nextInt();
                int a,b,c,sum,ans = 0;
                int[][] arr = new int[n][4];
                for(int i = 0;i<n;i++){
                        a = sc.nextInt();
                        b = sc.nextInt();
                        c = sc.nextInt();
                        sum = a+b+c;
                        int[] item = {sum,a,b,c};
                        arr[i] = item;
                }
                for(int i = 0;i<n;i++){
                        int sum1 = arr[i][0];
                        for(int m = i+1;m<n;m++){
                                int sum2 = arr[m][0];
                                if(Math.abs(sum1 -sum2)<=10){
                                        if(Math.abs(arr[i][1]-arr[m][1])<=5 &&Math.abs(arr[i][2]-arr[m][2])<=5 &&Math.abs(arr[i][3]-arr[m][3])<=5 ){
                                                ans++;
                                        }
                                }
                        }
                }
                System.out.println(ans);
        }
}",0
,"# 工艺品制作

## 题目描述

现有一个长宽高分别为 $w,x,h$ 组成的实心玻璃立方体，可以认为是由 $1\times1\times1$ 的数个小方块组成的，每个小方块都有一个坐标 $ ( i,j,k ) $。现在需要进行 $q$ 次切割。每次切割给出 $(x_1,y_1,z_1),(x_2,y_2,z_2)$ 这 6 个参数，保证 $x_1\le x_2$，$y_1\le y_2$，$z_1\le z_2$；每次切割时，使用激光工具切出一个立方体空洞，空洞的壁平行于立方体的面，空洞的对角点就是给出的切割参数的两个点。

换句话说，所有满足  $x_1\le i\le x_2$，$y_1\le j \le y_2 $，$z_1\le k\le z_2$ 的小方块 $(i,j,k)$ 的点都会被激光蒸发。例如有一个  $4\times4\times 4$ 的大方块，其体积为 $64$；给出参数 $(1,1,1),(2,2,2)$ 时，中间的 $8$ 块小方块就会被蒸发，剩下 $56$ 个小方块。现在想知道经过所有切割操作后，剩下的工艺品还剩下多少格小方块的体积？

## 输入格式

第一行三个正整数 $w,x,h$。

第二行一个正整数 $q$。

接下来 $q$ 行，每行六个整数 $(x_1,y_1,z_1),(x_2,y_2,z_2)$。

## 输出格式

输出一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
4 4 4
1
1 1 1 2 2 2
```

### 样例输出 #1

```
56
```

## 提示

数据保证，$1\le w,x,h\le 20$，$1 \leq q\le 100$。$1 \leq x_1 \leq x_2 \leq w$，$1 \leq y_1\leq y_2 \leq x$，$1 \leq z_1 \leq z_2 \leq h$。",数组,,,,,"import java.util.ArrayList;
import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc  = new Scanner(System.in);
                int a,b,c,n;
                a = sc.nextInt();
                b = sc.nextInt();
                c = sc.nextInt();
                int sum = a*b*c;
                n = sc.nextInt();
                ArrayList arr = new ArrayList();
                for(int i = 0;i<n;i++){
                        int a1 = sc.nextInt();
                        int b1 = sc.nextInt();
                        int c1 = sc.nextInt();
                        int a2 = sc.nextInt();
                        int b2 = sc.nextInt();
                        int c2 = sc.nextInt();
                        for(int x = a1;x<=a2;x++){
                                for(int y = b1;y<=b2;y++){
                                        for(int z = c1;z<=c2;z++){
                                                String num = x + "" "" + y + "" "" + z;
                                                if(!arr.contains(num))
                                                        arr.add(num);
                                        }
                                }
                        }
                }
                System.out.println(sum-arr.size());
        }
}",0
,"# 彩票摇奖

## 题目描述

为了丰富人民群众的生活、支持某些社会公益事业，北塔市设置了一项彩票。该彩票的规则是：

1. 每张彩票上印有 $7$ 个各不相同的号码，且这些号码的取值范围为 $1\sim33$。
2. 每次在兑奖前都会公布一个由七个各不相同的号码构成的中奖号码。
3. 共设置 $7$ 个奖项，特等奖和一等奖至六等奖。

兑奖规则如下：
- 特等奖：要求彩票上 $7$ 个号码都出现在中奖号码中。
- 一等奖：要求彩票上有 $6$ 个号码出现在中奖号码中。
- 二等奖：要求彩票上有 $5$ 个号码出现在中奖号码中。
- 三等奖：要求彩票上有 $4$ 个号码出现在中奖号码中。
- 四等奖：要求彩票上有 $3$ 个号码出现在中奖号码中。
- 五等奖：要求彩票上有 $2$ 个号码出现在中奖号码中。
- 六等奖：要求彩票上有 $1$ 个号码出现在中奖号码中。

注：兑奖时并不考虑彩票上的号码和中奖号码中的各个号码出现的位置。例如，中奖号码为 $23\ 31\ 1\ 14\ 19\ 17\ 18$，则彩票 $12\ 8\ 9\ 23\ 1\ 16\ 7$ 由于其中有两个号码（$23$ 和 $1$）出现在中奖号码中，所以该彩票中了五等奖。

现已知中奖号码和小明买的若干张彩票的号码，请你写一个程序帮助小明判断他买的彩票的中奖情况。

## 输入格式

输入的第一行只有一个自然数 $n$，表示小明买的彩票张数；

第二行存放了 $7$ 个介于 $1$ 和 $33$ 之间的自然数，表示中奖号码；

在随后的 $n$ 行中每行都有 $7$ 个介于 $1$ 和 $33$ 之间的自然数，分别表示小明所买的 $n$ 张彩票。

## 输出格式

依次输出小明所买的彩票的中奖情况（中奖的张数），首先输出特等奖的中奖张数，然后依次输出一等奖至六等奖的中奖张数。

## 样例 #1

### 样例输入 #1

```
2
23 31 1 14 19 17 18
12 8 9 23 1 16 7
11 7 10 21 2 9 31
```

### 样例输出 #1

```
0 0 0 0 0 1 1
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n\lt1000$。",数组,,,,,"import java.util.ArrayList;
import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc  = new Scanner(System.in);
                int[] ans = {0,0,0,0,0,0,0,0};
                ArrayList arr = new ArrayList();
                int n = sc.nextInt();
                for(int i = 0;i<7;i++)
                        arr.add(sc.nextInt());
                for(int i= 0;i<n;i++){
                        int s1 = 0;
                        for(int m = 0;m<7;m++){
                                if(arr.contains(sc.nextInt()))
                                        s1++;
                        }
                       ans[7-s1] += 1;
                }
                for(int i = 0;i<7;i++)
                        System.out.printf(""%d "",ans[i]);
        }
}",0
,"# 神奇的幻方

## 题目背景

NOIp2015 提高组 Day1T1

## 题目描述

幻方是一种很神奇的 $N\times N$ 矩阵：它由数字 $1,2,3,\cdots \cdots ,N \times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。

当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：

首先将 $1$ 写在第一行的中间。

之后，按如下方式从小到大依次填写每个数 $K \ (K=2,3,\cdots,N \times N)$ ：

1. 若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；
2. 若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；
3. 若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；
4. 若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。

现给定 $N$ ，请按上述方法构造 $N \times N$ 的幻方。

## 输入格式

一个正整数 $N$，即幻方的大小。

## 输出格式

共 $N$ 行，每行 $N$ 个整数，即按上述方法构造出的 $N \times N$ 的幻方，相邻两个整数之间用单空格隔开。

## 样例 #1

### 样例输入 #1

```
3
```

### 样例输出 #1

```
8 1 6
3 5 7
4 9 2
```

## 样例 #2

### 样例输入 #2

```
25
```

### 样例输出 #2

```
327 354 381 408 435 462 489 516 543 570 597 624 1 28 55 82 109 136 163 190 217 244 271 298 325
353 380 407 434 461 488 515 542 569 596 623 25 27 54 81 108 135 162 189 216 243 270 297 324 326
379 406 433 460 487 514 541 568 595 622 24 26 53 80 107 134 161 188 215 242 269 296 323 350 352
405 432 459 486 513 540 567 594 621 23 50 52 79 106 133 160 187 214 241 268 295 322 349 351 378
431 458 485 512 539 566 593 620 22 49 51 78 105 132 159 186 213 240 267 294 321 348 375 377 404
457 484 511 538 565 592 619 21 48 75 77 104 131 158 185 212 239 266 293 320 347 374 376 403 430
483 510 537 564 591 618 20 47 74 76 103 130 157 184 211 238 265 292 319 346 373 400 402 429 456
509 536 563 590 617 19 46 73 100 102 129 156 183 210 237 264 291 318 345 372 399 401 428 455 482
535 562 589 616 18 45 72 99 101 128 155 182 209 236 263 290 317 344 371 398 425 427 454 481 508
561 588 615 17 44 71 98 125 127 154 181 208 235 262 289 316 343 370 397 424 426 453 480 507 534
587 614 16 43 70 97 124 126 153 180 207 234 261 288 315 342 369 396 423 450 452 479 506 533 560
613 15 42 69 96 123 150 152 179 206 233 260 287 314 341 368 395 422 449 451 478 505 532 559 586
14 41 68 95 122 149 151 178 205 232 259 286 313 340 367 394 421 448 475 477 504 531 558 585 612
40 67 94 121 148 175 177 204 231 258 285 312 339 366 393 420 447 474 476 503 530 557 584 611 13
66 93 120 147 174 176 203 230 257 284 311 338 365 392 419 446 473 500 502 529 556 583 610 12 39
92 119 146 173 200 202 229 256 283 310 337 364 391 418 445 472 499 501 528 555 582 609 11 38 65
118 145 172 199 201 228 255 282 309 336 363 390 417 444 471 498 525 527 554 581 608 10 37 64 91
144 171 198 225 227 254 281 308 335 362 389 416 443 470 497 524 526 553 580 607 9 36 63 90 117
170 197 224 226 253 280 307 334 361 388 415 442 469 496 523 550 552 579 606 8 35 62 89 116 143
196 223 250 252 279 306 333 360 387 414 441 468 495 522 549 551 578 605 7 34 61 88 115 142 169
222 249 251 278 305 332 359 386 413 440 467 494 521 548 575 577 604 6 33 60 87 114 141 168 195
248 275 277 304 331 358 385 412 439 466 493 520 547 574 576 603 5 32 59 86 113 140 167 194 221
274 276 303 330 357 384 411 438 465 492 519 546 573 600 602 4 31 58 85 112 139 166 193 220 247
300 302 329 356 383 410 437 464 491 518 545 572 599 601 3 30 57 84 111 138 165 192 219 246 273
301 328 355 382 409 436 463 490 517 544 571 598 625 2 29 56 83 110 137 164 191 218 245 272 299
```

## 提示

对于 $100\%$ 的数据，对于全部数据， $1 \leq N \leq 39$ 且 $N$ 为奇数。","数组,模拟,枚举",,,,,"import java.util.Scanner;
 
public class main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int n = sc.nextInt();
                int[][] arr = new int[n][n];
                arr[0][n/2] = 1;
                int x = 0;
                int y = n/2;
                for(int i = 2;i<=n*n;i++){
                        if(x == 0){
                                if(y != n-1){
                                        x = n-1;
                                        y = y+1;
                                }
                                else if(y == n-1)
                                        x += 1;
                        }
                        else {
                                if(y == n-1){
                                        y = 0;
                                        x -=1;
                                }
                                else{
                                        if(arr[x-1][y+1] + 1 == 1){
                                                x -=1;
                                                y +=1;
                                        }
                                        else
                                                x += 1;
                                }
                        }
                        arr[x][y] = i;
                }
                for(int i = 0;i<n;i++){
                        for(int k = 0;k<n;k++){
                                System.out.printf(""%d "",arr[i][k]);
                        }
                        System.out.println();
                }
        }
}",1
,"# 显示屏

## 题目描述

液晶屏上，每个阿拉伯数字都是可以显示成 $3\times5$ 的点阵的（其中 `X` 表示亮点，`.` 表示暗点）。现在给出数字位数（不超过 $100$）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。

## 输入格式

第一行输入一个正整数 $n$，表示数字的位数。

第二行输入一个长度为 $n$ 的自然数。

## 输出格式

输出五行，表示显示屏上的数字。

## 样例 #1

### 样例输入 #1

```
10
0123456789
```

### 样例输出 #1

```
XXX...X.XXX.XXX.X.X.XXX.XXX.XXX.XXX.XXX
X.X...X...X...X.X.X.X...X.....X.X.X.X.X
X.X...X.XXX.XXX.XXX.XXX.XXX...X.XXX.XXX
X.X...X.X.....X...X...X.X.X...X.X.X...X
XXX...X.XXX.XXX...X.XXX.XXX...X.XXX.XXX
```

## 提示

数据保证，$1 \leq n \leq 100$。",数组,,,,,"import java.util.Scanner;
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int n = sc.nextInt();
                int a = 0;
                int b;
                String arr = sc.next();
                sc.close();
                String list =
                        ""XXX...X.XXX.XXX.X.X.XXX.XXX.XXX.XXX.XXX"" +
                        ""X.X...X...X...X.X.X.X...X.....X.X.X.X.X"" +
                        ""X.X...X.XXX.XXX.XXX.XXX.XXX...X.XXX.XXX"" +
                        ""X.X...X.X.....X...X...X.X.X...X.X.X...X"" +
                        ""XXX...X.XXX.XXX...X.XXX.XXX...X.XXX.XXX"";
                for(int i = 0;i<5;i++){//循环每一行
                        a = 39*i;//一行只有39个数据
                        for(int k = 0;k<n;k++){//循环每个一行
                               b = arr.charAt(k);
                               b = (b-'0')*4 + a;
                               for(int m = b;m<b+3;m++)
                                       System.out.print(list.charAt(m));
                               if(k != n-1)
                                 System.out.print(""."");
                        }
                        System.out.println();
                }
        }
}",1
,"# 梦中的统计

## 题目背景

Bessie 处于半梦半醒的状态。过了一会儿，她意识到她在数数，不能入睡。

## 题目描述

Bessie 的大脑反应灵敏，仿佛真实地看到了她数过的一个又一个数。她开始注意每一个数码（$0 \ldots 9$）：每一个数码在计数的过程中出现过多少次？

给出两个整数 $M$ 和 $N$，求在序列 $[M, M + 1, M + 2, \ldots, N - 1, N]$ 中每一个数码出现了多少次。

## 输入格式

第 $1$ 行: 两个用空格分开的整数 $M$ 和 $N$。

## 输出格式

第 $1$ 行: 十个用空格分开的整数，分别表示数码 $0 \ldots 9$ 在序列中出现的次数。

## 样例 #1

### 样例输入 #1

```
129 137
```

### 样例输出 #1

```
1 10 2 9 1 1 1 1 0 1
```

## 提示

数据保证，$1 \leq M \leq N \leq 2 \times 10^9$，$N-M \leq 5 \times 10^5$。","数组,字符串",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int a = sc.nextInt();
                int b = sc.nextInt();
                int[] arr = {0,0,0,0,0,0,0,0,0,0};
                for(;a<=b;a++){
                    String c = String.valueOf(a);
                    for(int i = 0;i<c.length();i++){
                        int d = c.charAt(i) - '0';
                        arr[d]++;
                    }
                }
            for(int i = 0;i<10;i++)
                System.out.printf(""%d "",arr[i]);
        }
}",0
,"# 珠心算测验

## 题目背景

NOIP2014 普及 T1

## 题目描述

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。


某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？


最近老师出了一些测验题，请你帮忙求出答案。

## 输入格式

共两行，第一行包含一个整数 $n$，表示测试题中给出的正整数个数。


第二行有 $n$ 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。

## 输出格式

一个整数，表示测验题答案。

## 样例 #1

### 样例输入 #1

```
4
1 2 3 4
```

### 样例输出 #1

```
2
```

## 提示

【样例说明】


由 $1+2=3,1+3=4$，故满足测试要求的答案为 $2$。  

注意，加数和被加数必须是集合中的两个不同的数。


【数据说明】


对于 $100\%$ 的数据，$3 \leq n \leq 100$，测验题给出的正整数大小不超过 $10,000$。","数组,模拟,枚举",,,,,"import java.util.*;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int n = sc.nextInt();
                int ans = 0;
                ArrayList arr = new ArrayList();
                for(int i = 0;i<n;i++)
                    arr.add(sc.nextInt());
                arr.sort(Comparator.naturalOrder());
                for(int i = n-1 ;i>1;i--){
                    for(int c = 0;c<i;c++){
                        if(arr.contains(((int)arr.get(i)-(int)arr.get(c))) && arr.indexOf(((int)arr.get(i)-(int)arr.get(c)))!=c){
                            ans++;
                            break;
                        }
                    }
                }
            System.out.println(ans);
        }
}",1
,"# Bovine Bones G

## 题面翻译

贝茜喜欢玩棋盘游戏和角色扮演游戏，所以她说服了约翰开车带她去小商店.在那里她买了三个骰子。这三个不同的骰子的面数分别为 $s_1,s_2,s_3$。

对于一个有 $S$ 个面的骰子每个面上的数字是 $1,2,3,\ldots,S$。每个面（上的数字）出现的概率均等。贝茜希望找出在所有“三个面上的数字的和”中，哪个和的值出现的概率最大。

现在给出每个骰子的面数，需要求出哪个所有“三个面上的数字的和”出现得最频繁。如果有很多个和出现的概率相同，那么只需要输出最小的那个。

数据范围： $2\le s_1\leq 20$，$2 \leq s_2\leq 20$，$2 \leq s_3\leq 40$。

## 题目描述

Bessie loves board games and role-playing games so she persuaded Farmer John to drive her to the hobby shop where she purchased three dice for rolling. These fair dice have S1, S2, and S3 sides

respectively (2 <= S1 <= 20; 2 <= S2 <= 20; 2 <= S3 <= 40). 

Bessie rolls and rolls and rolls trying to figure out which three-dice sum appears most often.

Given the number of sides on each of the three dice, determine which three-dice sum appears most frequently. If more than one sum can appear most frequently, report the smallest such sum.

POINTS: 70

## 输入格式

\* Line 1: Three space-separated integers: S1, S2, and S3

## 输出格式

\* Line 1: The smallest integer sum that appears most frequently when the dice are rolled in every possible combination.

## 样例 #1

### 样例输入 #1

```
3 2 3
```

### 样例输出 #1

```
5
```

## 提示

Here are all the possible outcomes.

```
1 1 1 -> 3  
1 2 1 -> 4  
2 1 1 -> 4  
2 2 1 -> 5  
3 1 1 -> 5  
3 2 1 -> 6 
1 1 2 -> 4  
1 2 2 -> 5  
2 1 2 -> 5  
2 2 2 -> 6  
3 1 2 -> 6  
3 2 2 -> 7 
1 1 3 -> 5  
1 2 3 -> 6  
2 1 3 -> 6  
2 2 3 -> 7  
3 1 3 -> 7  
3 2 3 -> 8
```
Both 5 and 6 appear most frequently (five times each), so 5 is the answer.","数组,枚举",,,,,"import java.util.*;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int a = sc.nextInt();
                int b = sc.nextInt();
                int c = sc.nextInt();
                int max = Math.max(a,Math.max(b,c));
                int min = Math.min(a,Math.min(b,c));
                int d = a+b+c-max-min;
                int ans;
                if(d<=max-min+1)
                        ans = 1+min+d;
                else
                        ans = 1+max+(d - (max - min + 1))/2 + 1;
                System.out.println(ans);
        }
}",0
,"# 开灯

## 题目描述

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 的灯的开关各按一次。其中 $\lfloor k \rfloor$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？

## 输入格式

第一行一个正整数 $n$，表示 $n$ 次操作。

接下来有 $n$ 行，每行两个数，$a_i,t_i$。其中 $a_i$ 是实数，小数点后一定有 $6$ 位，$t_i$ 是正整数。

## 输出格式

仅一个正整数，那盏开着的灯的编号。

## 样例 #1

### 样例输入 #1

```
3
1.618034 13
2.618034 7
1.000000 21
```

### 样例输出 #1

```
20
```

## 提示

记 $T=\sum \limits_{i=1}^n t_i = t_1+t_2+t_3+\dots+t_n$。

- 对于 $30\%$ 的数据，满足 $T \le 1000$；
- 对于 $80\%$ 的数据，满足 $T \le 200000$；
- 对于 $100\%$ 的数据，满足 $T \le 2000000$；
- 对于 $100\%$ 的数据，满足 $n \le 5000$，$1 \le a_i<1000$，$1 \le t_i \le T$。

数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\times a_i$ 的最大值不超过 $2000000$。","数组,进制",,,,,"import java.util.*;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int n = sc.nextInt();
                boolean[] b= new boolean[2000000];
                double[] a = new double[n];
                int[] t = new int[n];
                for(int i = 0; i<n;i++){
                        a[i] = sc.nextDouble();
                        t[i] = sc.nextInt();
                        for(int k = 1;k<=t[i];k++)
                            b[(int)Math.floor(a[i]*k)] = !b[(int)Math.floor(a[i]*k)];
                }
                for(int k = 0;k<2000000;k++){
                        if(b[(int)Math.floor(k)]){
                                System.out.println(k);
                                break;
                        }
                }
        }
}",0
,"# 蛇形方阵

## 题目描述

给出一个不大于 $9$ 的正整数 $n$，输出 $n\times n$ 
的蛇形方阵。

从左上角填上 $1$ 开始，顺时针方向依次填入数字，如同样例所示。注意每个数字有都会占用 $3$ 个字符，前面使用空格补齐。

## 输入格式

输入一个正整数 $n$，含义如题所述。

## 输出格式

输出符合题目要求的蛇形矩阵。

## 样例 #1

### 样例输入 #1

```
4
```

### 样例输出 #1

```
1  2  3  4
 12 13 14  5
 11 16 15  6
 10  9  8  7
```

## 提示

数据保证，$1 \leq n \leq 9$。",数组,,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int x = 0, y = 0;
        int[][] arr = new int[n][n];
        int a = 1;//当前过程序号
        arr[0][0] = 1;//设定原点/起始点
        for(int i = 2;i<=n*n;i++){//下面 || 前的条件是为了防止超范围
            if(a == 1 && (y==n-1 || arr[x][y+1] != 0)){
                a++;
            }
            else if(a == 2 && (x==n-1 || arr[x+1][y] != 0)){
                a++;
            }
            else if(a == 3 && (y==0 || arr[x][y-1] != 0)){
                a++;
            }
            else if(a==4 &&(x==0 || arr[x-1][y] != 0)){
                a = 1;
            }
            switch(a){
                case 1: y++;break;
                case 2: x++;break;
                case 3: y--;break;
                case 4: x--;break;
            }
            arr[x][y] = i;
        }
        for(int i = 0;i<n;i++){
            for(int k = 0;k<n;k++){
                System.out.printf(""%3d"",arr[i][k]);
            }
            System.out.println();
        }
    }
}",0
,"# 杨辉三角

## 题目描述

给出 $n(n\le20)$，输出杨辉三角的前 $n$ 行。

如果你不知道什么是杨辉三角，可以观察样例找找规律。

## 输入格式

## 输出格式

## 样例 #1

### 样例输入 #1

```
6
```

### 样例输出 #1

```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
```",数组,,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] arr = new int[n][n];
        arr[0][0] = 1;
        for(int i = 1;i<n;i++){
            for(int  k = 0;k<=i;k++){
                if(k==i || k==0)
                    arr[i][k] = 1;
                else{
                    arr[i][k] = arr[i-1][k-1]+arr[i-1][k];
                }
            }
        }
        for(int i = 0;i<n;i++){
            for(int  k = 0;k<=i;k++){
                System.out.printf(""%d "",arr[i][k]);
            }
            System.out.println();
        }
    }
}",0
,"# 【Mc生存】插火把

## 题目描述

话说有一天 linyorson 在“我的世界”开了一个 $n \times n$ 的方阵，现在他有 $m$ 个火把和 $k$ 个萤石，分别放在 $(x_1, y_1) \sim (x_m, y_m)$ 和 $(o_1, p_1) \sim (o_k, p_k)$ 的位置，没有光并且没放东西的地方会生成怪物。请问在这个方阵中有几个点会生成怪物？

P.S. 火把的照亮范围是：

```
    |暗|暗| 光 |暗|暗|
    |暗|光| 光 |光|暗|
    |光|光|火把|光|光|
    |暗|光| 光 |光|暗|
    |暗|暗| 光 |暗|暗|
```

萤石：

```
    |光|光| 光 |光|光|
    |光|光| 光 |光|光|
    |光|光|萤石|光|光|
    |光|光| 光 |光|光|
    |光|光| 光 |光|光|
```

## 输入格式

输入共 $m + k + 1$ 行。  
第一行为 $n, m, k$。  
第 $2$ 到第 $m + 1$ 行分别是火把的位置 $x_i, y_i$。  
第 $m + 2$ 到第 $m + k + 1$ 行分别是萤石的位置 $o_i, p_i$。

注：可能没有萤石，但一定有火把。

## 输出格式

有几个点会生出怪物。

## 样例 #1

### 样例输入 #1

```
5 1 0
3 3
```

### 样例输出 #1

```
12
```

## 提示

数据保证，$1 \le n \le 100$，$1 \leq m+k \leq 25$，$1 \leq m \leq 25$，$0 \leq k \leq 5$。","数组,模拟",,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int ans = 0;
        boolean[][] arr = new boolean[n][n];
        for(int i = 0;i<m;i++){
            int x = sc.nextInt() - 1;
            int y = sc.nextInt() - 1 ;
            for(int a = x-1;a<=x+1;a++){
                for(int b = y-1;b<=y+1;b++){
                    try{
                        arr[a][b] = true;
                    }catch (Exception e){}
                }
            }
            try{arr[x-2][y] = true;}catch (Exception e){}
            try{arr[x][y-2] = true;}catch (Exception e){}
            try{arr[x][y+2] = true;}catch (Exception e){}
            try{arr[x+2][y] = true;}catch (Exception e){}
        }
        for(int i = 0;i<k;i++){
            int x = sc.nextInt() - 1 ;
            int y = sc.nextInt() - 1;
            for(int a = x-2;a<=x+2;a++){
                for(int b = y-2;b<=y+2;b++){
                    try{
                        arr[a][b] = true;
                    }catch (Exception e){}
                }
            }
        }
        for(int i = 0;i<n;i++){
            for(int j = 0;j<n;j++){
                if(!arr[i][j])
                    ans++;
            }
        }
        System.out.println(ans);
    }
}",0
,"# 压缩技术

## 题目描述

设某汉字由 $N \times N$ 的 $\texttt 0$ 和 $\texttt 1$ 的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 $\texttt 0$，第二个数表示接下来连续有几个 $\texttt 1$，第三个数再接下来连续有几个 $\texttt 0$，第四个数接着连续几个 $\texttt 1$，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： $\texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7}$ （第一个数是 $N$ ,其余各位表示交替表示0和1 的个数，压缩码保证 $N \times N=$ 交替的各位数之和）

## 输入格式

数据输入一行，由空格隔开的若干个整数，表示压缩码。

其中，压缩码的第一个数字就是 $N$，表示这个点阵应当是 $N\times N$ 的大小。

接下来的若干个数字，含义如题目描述所述。

## 输出格式

输出一个 $N\times N$ 的 01 矩阵，表示最后的汉字点阵图（点阵符号之间不留空格）。

## 样例 #1

### 样例输入 #1

```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```

### 样例输出 #1

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

## 提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/rsx9qytk.png)

## 数据范围

数据保证，$3\leq N\leq 200$。","数组,模拟,枚举",,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        boolean check = true;
        int num = 0;
        int sum = 0;
        while (sum != n*n){
            int b = sc.nextInt();
            sum +=b;
            for(int c =0;c<b;c++){
                if(check)
                    System.out.print(0);
                else
                    System.out.print(1);
                num++;
                if(num == n) {
                    System.out.println();
                    num = 0;
                }
            }
            check = !check;
        }
    }
}",0
,"# 压缩技术（续集版）

## 题目描述

设某汉字由 $N \times N$ 的 $\texttt 0$ 和 $\texttt 1$ 的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 $\texttt 0$，第二个数表示接下来连续有几个 $\texttt 1$，第三个数再接下来连续有几个 $\texttt 0$，第四个数接着连续几个 $\texttt 1$，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： $\texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7}$ （第一个数是 $N$ ,其余各位表示交替表示0和1 的个数，压缩码保证 $N \times N=$ 交替的各位数之和）

## 输入格式

汉字点阵图（点阵符号之间不留空格）。

## 输出格式

输出一行，压缩码。

## 样例 #1

### 样例输入 #1

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

### 样例输出 #1

```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```

## 提示

数据保证，$3\leq N\leq 200$。","数组,模拟,字符串",,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String a;
        int n = 200,num = 0;
        int x = 0,y = 0;
        ArrayList b = new ArrayList();
       while(num != n) {
           a = sc.nextLine();
           n = a.length();
            for (int i = 0; i < n; i++) {
                int c = a.charAt(i) - '0';
                if (c == 0) {
                    x++;
                    if (y != 0) {
                        b.add(y);
                        y = 0;
                    }
                }
                else {
                    y++;
                    if (x != 0 || (num+i) ==0) {
                        b.add(x);
                        x = 0;
                    }
                }
            }
            num++;
        }
        System.out.printf(""%d "",n);
        b.add(x==0?y:x);
        for(int i = 0;i<b.size();i++){
            System.out.printf(""%d "",b.get(i));
        }
    }
}",0
,"# 方块转换 Transformations

## 题目描述

一块 $n \times n$ 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：

- 转 $90\degree$：图案按顺时针转 $90\degree$。

- 转 $180\degree$：图案按顺时针转 $180\degree$。

- 转 $270\degree$：图案按顺时针转 $270\degree$。

- 反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。

- 组合：图案在水平方向翻转，然后再按照 $1 \sim 3$ 之间的一种再次转换。

- 不改变：原图案不改变。

- 无效转换：无法用以上方法得到新图案。

如果有多种可用的转换方法，请选择序号最小的那个。

只使用上述 $7$ 个中的一个步骤来完成这次转换。

## 输入格式

第一行一个正整数 $n$。   

然后 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示初始的正方形。

接下来 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示最终的正方形。

## 输出格式

单独的一行包括 $1 \sim 7$ 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。

## 样例 #1

### 样例输入 #1

```
3
@-@
---
@@-
@-@
@--
--@
```

### 样例输出 #1

```
1
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$。

题目翻译来自 NOCOW。

USACO Training Section 1.2","数组,模拟",,,,,"import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int x = 0 ,x1 = 0,ans = 7;
        boolean b1 = true;
        char[][] a = new char[n][n];
        char[][] a1 = new char[n][n];
        for(int i = 0;i<n;i++){
            String b = sc.next();
            for(int k = 0;k<n;k++) {
                a[i][k] = b.charAt(k);
                if(a[i][k] == '@')
                    x++;
            }
        }
        for(int i = 0;i<n;i++){
            String b = sc.next();
            for(int k = 0;k<n;k++) {
                a1[i][k] = b.charAt(k);
                if(a[i][k] != a1[i][k])
                    b1 = false;
                if(a1[i][k] == '@')
                    x1++;
            }
        }
        if(x != x1)
            System.out.println(7);
        else{
            ans = f1(a,a1) == 0?f2(a,a1):f1(a,a1);
            if(ans == 0 && !b1)
                System.out.println(7);
            else
                System.out.println(ans == 0?6:ans);
        }
    }
    private static int f1(char[][] a, char[][] b){
        int n = a[0].length;
        boolean b1 = true,b2 = true,b3 = true;
        char[][] c1 = new char[n][n];
        char[][] c2 = new char[n][n];
        char[][] c3 = new char[n][n];
        for(int i = 0;i<n;i++){
            for(int k = 0;k<n;k++){
                if(b1)
                    c1[i][k] = a[n-k-1][i];
                if(b2)
                    c2[i][k] = a[n-i-1][n-k-1];
                if(b3)
                    c3[i][k] = a[k][n-i-1];
                if(c1[i][k] != b[i][k])
                    b1 = false;
                if(c2[i][k] != b[i][k])
                    b2 = false;
                if(c3[i][k] != b[i][k])
                    b3 = false;
                if(!b1 && !b2 && !b3)
                    break;
            }
        }
        if(b1)
            return 1;
        else if(b2)
            return 2;
        else if(b3)
            return 3;
        else
            return 0;
    }
    private static int f2(char[][] a, char[][] b){
        int n = a[0].length;
        boolean d = true;
        char[][] c = new char[n][n];
        for(int i = 0;i<n;i++){
            for(int k = 0;k<n;k++){
                c[i][k] = a[i][n-k-1];
                if(c[i][k] != b[i][k])
                    d = false;
            }
        }
        if(d)
            return 4;
        else{
            if(f1(c,b) == 0)
                return 0;
            else
                return 5;
        }
    }
}",1
,"# 找最小值

## 题目描述

给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中最小值是什么。

## 输入格式

第一行输入一个正整数 $n$，表示数字个数。

第二行输入 $n$ 个非负整数，表示 $a_1,a_2 \dots a_n$，以空格隔开。

## 输出格式

输出一个非负整数，表示这 $n$ 个非负整数中的最小值。

## 样例 #1

### 样例输入 #1

```
8
1 9 2 6 0 8 1 7
```

### 样例输出 #1

```
0
```

## 提示

数据保证，$n\le100$ 且 $0\le a_i \le 1000$。",循环结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int a,b = 1000;
  int n = sc.nextInt();
  for(int i = 0;i<n;i++) {
   a = sc.nextInt();
   b= b<a?b:a;
  }
  System.out.println(b);
 }
}",0
,"# 分类平均

## 题目描述

给定 $n$ 和 $k$，将从 1 到 $n$ 之间的所有正整数可以分为两类：A 类数可以被 $k$ 整除（也就是说是 $k$ 的倍数），而 B 类数不能。请输出这两类数的平均数，精确到小数点后 $1$ 位，用空格隔开。

数据保证两类数的个数都不会是 $0$。

## 输入格式

输入两个正整数 $n$ 与 $k$。

## 输出格式

输出一行，两个实数，分别表示 A 类数与 B 类数的平均数。精确到小数点后一位。

## 样例 #1

### 样例输入 #1

```
100 16
```

### 样例输出 #1

```
56.0 50.1
```

## 提示

数据保证，$1 \leq n\leq 10000$，$1 \leq k \leq 100$。",循环结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  int k = sc.nextInt();
  double a = 0 ,b = 0;
  int n1 = 0, n2 = 0;
  for(int i = 1;i<=n;i++) {
   if(i%k == 0) {
    a += i;
    n1++;
   }
   else {
    b += i;
    n2++;
   }
  }
  System.out.printf(""%.1f %.1f"",a/n1,b/n2);
 }
}",0
,"# 一尺之棰

## 题目描述

《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 $a$ 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 $2$，向下取整）。第几天的时候木棍的长度会变为 $1$？

## 输入格式

输入一个正整数 $a$，表示木棍长度。

## 输出格式

输出一个正整数，表示要第几天的时候木棍长度会变为 $1$。

## 样例 #1

### 样例输入 #1

```
100
```

### 样例输出 #1

```
7
```

## 提示

数据保证，$1 \le a\le 10^9$。",循环结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  int k = sc.nextInt();
  double a = 0 ,b = 0;
  int n1 = 0, n2 = 0;
  for(int i = 1;i<=n;i++) {
   if(i%k == 0) {
    a += i;
    n1++;
   }
   else {
    b += i;
    n2++;
   }
  }
  System.out.printf(""%.1f %.1f"",a/n1,b/n2);
 }
}",0
,"# 数字直角三角形

## 题目描述

给出 $n$，请输出一个直角边长度是 $n$ 的数字直角三角形。所有数字都是 $2$ 位组成的，如果没有 $2$ 位则加上前导 $0$。

## 输入格式

输入一个正整数 $n$。

## 输出格式

输出如题目要求的数字直角三角形。

## 样例 #1

### 样例输入 #1

```
5
```

### 样例输出 #1

```
0102030405
06070809
101112
1314
15
```

## 提示

数据保证，$1\le n\le13$。",循环结构,,,,,"import java.math.MathContext;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  int b = 1;
  for(int i = n;i>=1;i--) {
   for(int a = 1;a<=i;a++) {
    System.out.printf(""%02d"",b);
    b++;
   }
   System.out.println();
  }
 }
}",0
,"# 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 输入格式

一个正整数 $n$。

## 输出格式

一个正整数 $S$，表示计算结果。

## 样例 #1

### 样例输入 #1

```
3
```

### 样例输出 #1

```
9
```

## 提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题",循环结构,,,,,"import java.math.BigInteger;
import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  BigInteger a = new BigInteger(""0"");
  BigInteger c = BigInteger.valueOf(1);
  for(int i =1;i<=n;i++) {
   for(int b = i;b<=i;b++) {
    c = c.multiply(BigInteger.valueOf(b));
   }
  a = a.add(c);
  }
  if(n==0)
   System.out.println(0);
  else
   System.out.println(a);
 }
}",1
,"# 计数问题

## 题目背景

NOIP2013 普及组 T1

## 题目描述

试计算在区间 $1$ 到 $n$ 的所有整数中，数字 $x$（$0\le x\le9$）共出现了多少次？例如，在 $1$ 到 $11$ 中，即在 $1,2,3,4,5,6,7,8,9,10,11$ 中，数字 $1$ 出现了 $4$ 次。

## 输入格式

$2$ 个整数 $n,x$，之间用一个空格隔开。

## 输出格式

$1$ 个整数，表示 $x$ 出现的次数。

## 样例 #1

### 样例输入 #1

```
11 1
```

### 样例输出 #1

```
4
```

## 提示

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le x \le 9$。","循环结构,模拟,字符串",,,,,"import java.util.Scanner;
 
public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  int d = 0;
  char b = sc.next().charAt(0);
  int a = 0;
  for(int i = 1;i<=n;i++) {
   String e = String.valueOf(i);
   String c = e.replaceAll(b+"""","""");
   int a1 = e.length() - c.length();
   d += a1;
  }
  System.out.println(d);
 }
}",0
,"# 级数求和

## 题目描述

已知：$S_n= 1+\dfrac{1}{2}+\dfrac{1}{3}+…+\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。

现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。

## 输入格式

一个正整数 $k$。

## 输出格式

一个正整数 $n$。

## 样例 #1

### 样例输入 #1

```
1
```

### 样例输出 #1

```
2
```

## 提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le k \le 15$。

**【题目来源】**

NOIP 2002 普及组第一题",循环结构,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int k = sc.nextInt();
            double sum = 0;
            for(int i = 1;;i++){
                sum += 1.0/i;
                if(k<sum) {
                    k = i;
                    break;
                }
            }
            System.out.println(k);
        }
    }",0
,"# 金币

## 题目背景

NOIP2015 普及组 T1

## 题目描述

国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 $n$ 天每天收到 $n$ 枚金币后，骑士会在之后的连续 $n+1$ 天里，每天收到 $n+1$ 枚金币。

请计算在前 $k$ 天里，骑士一共获得了多少金币。

## 输入格式

一个正整数 $k$，表示发放金币的天数。

## 输出格式

一个正整数，即骑士收到的金币数。

## 样例 #1

### 样例输入 #1

```
6
```

### 样例输出 #1

```
14
```

## 样例 #2

### 样例输入 #2

```
1000
```

### 样例输出 #2

```
29820
```

## 提示

**【样例 1 说明】**

骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 $1+2+2+3+3+3=14$ 枚金币。


对于 $100\%$ 的数据，$1\le k\le 10^4$。","循环结构,模拟",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int m = 1;
            int sum = 0;
            int i = 0;
            int k = sc.nextInt();
            for(;;){
                for(int l = 1;l<=m;l++){
                    sum += m;
                    i++;
                    if(l == m){
                        m++;
                        break;
                    }
                    if(i == k)
                        break;
                }
                if(i == k)
                    break;
            }
            System.out.println(sum);
        }
    }",0
,"# 数列求和

## 题目描述

计算 $1+2+3+\cdots+(n-1)+n$ 的值，其中正整数 $n$ 不大于 100。由于你没有高斯聪明，所以你不被允许使用等差数列求和公式直接求出答案。

## 输入格式

输入一个正整数 $n$。

## 输出格式

输出一个正整数，表示最后求和的答案。

## 样例 #1

### 样例输入 #1

```
100
```

### 样例输出 #1

```
5050
```

## 提示

数据保证，$1 \leq n \leq 100$。",循环结构,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int sum = 0;
            int a = sc.nextInt();
            for(int i = 0;i<=a;i++){
                sum+=i;
            }
            System.out.println(sum);
        }
    }",0
,"# 质数口袋

## 题目描述

小 A 有一个质数口袋，里面可以装各个质数。他从 $2$ 开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。

口袋的负载量就是口袋里的所有数字之和。

但是口袋的承重量有限，装的质数的和不能超过 $L$。给出 $L$，请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数的个数，数字之间用换行隔开。

## 输入格式

一行一个正整数 $L$。

## 输出格式

将这些质数从小往大输出，然后输出最多能装下的质数个数，所有数字之间有一空行。

## 样例 #1

### 样例输入 #1

```
100
```

### 样例输出 #1

```
2
3
5
7
11
13
17
19
23
9
```

## 样例 #2

### 样例输入 #2

```
5
```

### 样例输出 #2

```
2
3
2
```

## 样例 #3

### 样例输入 #3

```
11
```

### 样例输出 #3

```
2
3
5
3
```

## 提示

数据保证，$1 \le L \le {10}^5$。","[""循环结构"",""质数""]",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int k = sc.nextInt();
            int sum = 0;
            int n = 0;
            for(int m = 2;;m++){
                if(b(m)){
                    sum+=m;
                    if(sum>k)
                        break;
                    n++;
                    System.out.println(m);
                }
            }
            System.out.println(n);
        }
        static boolean b(int q){
            for(int a = 2;a<=Math.sqrt(q);a++){
                if(q%a == 0)
                    return false;
            }
            return true;
        }
    }",1
,"# 回文质数 Prime Palindromes

## 题目描述

因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。

写一个程序来找出范围 $[a,b] (5 \le a < b \le 100,000,000)$（一亿）间的所有回文质数。

## 输入格式

第一行输入两个正整数 $a$ 和 $b$。

## 输出格式

输出一个回文质数的列表，一行一个。

## 样例 #1

### 样例输入 #1

```
5 500
```

### 样例输出 #1

```
5
7
11
101
131
151
181
191
313
353
373
383
```

## 提示

Hint 1: Generate the palindromes and see if they are prime.

提示 1: 找出所有的回文数再判断它们是不是质数（素数）.


Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.

提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。


题目翻译来自NOCOW。

USACO Training Section 1.5


产生长度为 $5$ 的回文数：

```cpp
for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
     for (d2 = 0; d2 <= 9; d2++) {
         for (d3 = 0; d3 <= 9; d3++) {
           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)
         }
     }
 }

```","循环结构,质数",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int a = sc.nextInt();
            int b = sc.nextInt();
            int pa = 0;
            String sb = String.valueOf(b);
            int bl = sb.length();
            for(int i = 1;i<=bl;i++) {
                switch (i) {
                    case 1:
                        //质数一定不是二的倍数，简化掉以2的倍数结尾的数
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            pa = a1;
                            if (pa >= a && pa <= b && zhishu(pa))
                                System.out.println(pa);
                        }
                        break;
                    case 2:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            pa = a1 * 10 + a1;
                            if (pa >= a && pa <= b && zhishu(pa))
                                System.out.println(pa);
                        }
                        break;
                    case 3:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                pa = a1 * 100 + b1 * 10 + a1;
                                if (pa >= a && pa <= b && zhishu(pa))
                                    System.out.println(pa);
                            }
                        }
                        break;
//                    case 4:
//                        for (int a1 = 1; a1 <= 9; a1 += 2) {
//                            for (int b1 = 0; b1 <= 9; b1++) {
//                                pa = a1 * 1000 + b1 * 100 + b1 * 10 + a1;
//                                if (pa >= a && pa <= b && zhishu(pa))
//                                    System.out.println(pa);
//                            }
//                        }
//                        break;
                    //偶数次回文数没有质数，除11外
                    case 5:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    pa = a1 * 10000 + b1 * 1000 + c1 * 100 + b1 * 10 + a1;
                                    if (pa >= a && pa <= b && zhishu(pa))
                                        System.out.println(pa);
                                }
                            }
                        }
                        break;
                    case 6:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    pa = a1 * 100000 + b1 * 10000 + c1 * 1000 + c1*100+ b1 * 10 + a1;
                                    if (pa >= a && pa <= b && zhishu(pa))
                                        System.out.println(pa);
                                }
                            }
                        }
                        break;
                    case 7:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    for(int d1 = 0;d1<=9;d1++) {
                                        pa = a1 * 1000000 + b1 * 100000 + c1 * 10000+ d1*1000+ c1 * 100 + b1 * 10 + a1;
                                        if (pa >= a && pa <= b && zhishu(pa))
                                            System.out.println(pa);
                                    }
                                }
                            }
                        }
                        break;
                    case 8:
                        for (int a1 = 1; a1 <= 9; a1 += 2) {
                            for (int b1 = 0; b1 <= 9; b1++) {
                                for (int c1 = 0; c1 <= 9; c1++) {
                                    for(int d1 = 0;d1<=9;d1++) {
                                        pa = a1 * 10000000 + b1 * 1000000 + c1 * 100000+ d1*10000 +d1*1000+ c1 * 100 + b1 * 10 + a1;
                                        if (pa >= a && pa <= b && zhishu(pa))
                                            System.out.println(pa);
                                    }
                                }
                            }
                        }
                        break;
//                    case 9:
//                        for (int a1 = 1; a1 <= 9; a1 += 2) {
//                            for (int b1 = 0; b1 <= 9; b1++) {
//                                for (int c1 = 0; c1 <= 9; c1++) {
//                                    for(int d1 = 0;d1<=9;d1++) {
//                                        for(int e1 = 0;e1<=9;e1++) {
//                                            pa = a1 * 100000000 + b1 * 10000000 + c1 * 1000000 + d1 * 100000+e1*10000 + d1 * 1000 + c1 * 100 + b1 * 10 + a1;
//                                            if (pa >= a && pa <= b && zhishu(pa))
//                                                System.out.println(pa);
//                                        }
//                                    }
//                                }
//                            }
//                        }
//                        break;
                    //一亿并不是回文数，也不是质数
                }
            }
        }
        static boolean zhishu(int a){
            if(a<5)
                return false;
            for(int b = 2;b <= Math.sqrt(a);b++){
                if( a % b == 0)
                    return false;
            }
            return true;
    }
}",1
,"# 小玉在游泳

## 题目描述

小玉开心的在游泳，可是她很快难过的发现，自己的力气不够，游泳好累哦。已知小玉第一步能游 $2$ 米，可是随着越来越累，力气越来越小，她接下来的每一步都只能游出上一步距离的 $98\%$。现在小玉想知道，如果要游到距离 $s$ 米的地方，她需要游多少步呢。请你编程解决这个问题。

## 输入格式

输入一个实数 $s$（单位：米），表示要游的目标距离。

## 输出格式

输出一个整数，表示小玉一共需要游多少步。

## 样例 #1

### 样例输入 #1

```
4.3
```

### 样例输出 #1

```
3
```

## 提示

数据保证，$0 \leq s < 100$，且 $s$ 小数点后最多只有一位。",循环结构,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            double a = sc.nextDouble();
            double b = 2;
            double c = 2;
            int n = 1;
            for(;;){
                if(c<a) {
                    b *= 0.98;
                    c += b;
                    n++;
                }
                else{
                    System.out.println(n);
                    break;
                }
            }
        }
}",0
,"# 数字反转

## 题目描述

给定一个整数 $N$，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例 2）。

## 输入格式

一个整数 $N$。

## 输出格式

一个整数，表示反转后的新数。

## 样例 #1

### 样例输入 #1

```
123
```

### 样例输出 #1

```
321
```

## 样例 #2

### 样例输入 #2

```
-380
```

### 样例输出 #2

```
-83
```

## 提示

**【数据范围】**

$-1,000,000,000\leq N\leq 1,000,000,000 $。

noip2011 普及组第一题","循环结构,模拟,字符串",,,,,"import java.util.Scanner;
//此题坑点 ： 需考虑0的情况
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            char[] arr = new char[str.length()];
            boolean is = false;
            boolean a = false;
            if(str.length() == 1)
                System.out.println(str.charAt(0));
            else if(str.charAt(0) == '-')
                arr = new char[str.length() - 1 ];
            for(int i = 0 ; i<arr.length;i++){
                if (str.charAt(0) == '-'){
                    is = true;
                    arr[i] = str.charAt(i+1);
                }
                else{
                    arr[i] = str.charAt(i);
                }
            }
            if(is)
                System.out.printf(""-"");
            for(int i = 0;i<arr.length;i++) {
                if(arr[arr.length - i -1] != '0' || a){
                    System.out.printf(""%c"",arr[arr.length - i - 1]);
                    a = true;
                }
            }
        }
}",0
,"# 月落乌啼算钱（斐波那契数列）

## 题目背景

（本道题目木有隐藏歌曲……不用猜了……）

《爱与愁的故事第一弹・heartache》最终章。

吃完 pizza，月落乌啼知道超出自己的预算了。为了不在爱与愁大神面前献丑，只好还是硬着头皮去算钱……

## 题目描述

算完钱后，月落乌啼想着：“你坑我！”于是当爱与愁大神问多少钱时，月落乌啼说了一堆乱码。爱与愁大神说：“算了算了，我只问第 $n$ 样菜价格多少？”月落乌啼写出了：

$$F_n=\dfrac{\left(\frac{1+\sqrt{5}}{2}\right)^n-\left(\frac{1-\sqrt{5}}{2}\right)^n}{\sqrt{5}}$$

由于爱与愁大神学过编程，于是就用 $1$ 分钟的时间求出了 $F_n$ 的结果。月落乌啼为此大吃一惊。你能学学爱与愁大神求出 $F_n$ 的值吗？

## 输入格式

一行一个自然数 $n$。

## 输出格式

只有 $1$ 行一个实数 $F_n$，保留两位小数。

## 样例 #1

### 样例输入 #1

```
6
```

### 样例输出 #1

```
8.00
```

## 提示

对于所有数据：$0 \leq n\leq 48$。","循环结构,模拟",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            double a = Math.sqrt(5);
            double b = (Math.pow((1+a),n)-Math.pow((1 - a),n))/(Math.pow(2,n)*a);
            System.out.printf(""%.2f"",b);
        }
}",0
,"# 求极差 / 最大跨度值

## 题目描述

给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。

## 输入格式

第一行输入一个正整数 $n$，表示整数个数。

第二行输入 $n$ 个整数 $a_1,a_2 \dots a_n$，以空格隔开。

## 输出格式

输出一个整数，表示这 $n$ 个整数的极差。

## 样例 #1

### 样例输入 #1

```
6
4 1 5 1 4 1
```

### 样例输出 #1

```
4
```

## 提示

数据保证，$1 \leq n\leq 100$，$0\le a_i \le 1000$。",循环结构,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int min = 1000,max = 0;
            for(int i = 0;i<n;i++) {
                int a = sc.nextInt();
                if(a>max)
                    max = a;
                if(a<min)
                    min = a;
            }
            int c = max - min;
            System.out.println(c);
        }
}",0
,"# 最长连号

## 题目描述

输入长度为 $n$ 的一个正整数序列，要求输出序列中最长连号的长度。

连号指在序列中，从小到大的连续自然数。

## 输入格式

第一行，一个整数 $n$。

第二行，$n$ 个整数 $a_i$，之间用空格隔开。

## 输出格式

一个数，最长连号的个数。

## 样例 #1

### 样例输入 #1

```
10
1 5 6 2 3 4 5 6 8 9
```

### 样例输出 #1

```
5
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq a_i \leq 10^9$。","循环结构,模拟",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int b = sc.nextInt();
            int max = 1;
            int m = 1;
            for(int i = 0; i<n-1;i++){
                int a = sc.nextInt();
                if(b+1 == a){
                    m++;
                }
                else{
                    m = 1;
                }
                if(m>max)
                    max = m;
                b = a;
            }
            System.out.println(max);
        }
}",0
,"# 质因数分解

## 题目描述

已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。

## 输入格式

输入一个正整数 $n$。

## 输出格式

输出一个正整数 $p$，即较大的那个质数。

## 样例 #1

### 样例输入 #1

```
21
```

### 样例输出 #1

```
7
```

## 提示

$1 \le n\le 2\times 10^9$

NOIP 2012 普及组 第一题","循环结构,素数,质数",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int a = sc.nextInt();
            int b = 2;
            for(int i = 1;2*i+1<Math.sqrt(a);i++){
                if(a%b==0){
                    break;
                }
                b = 2*i+1;
            }
            System.out.println(Math.max(b, a / b));
        }
}",1
,"# 求三角形

## 题目描述

模仿例题，打印出不同方向的正方形，然后打印三角形矩阵。中间有个空行。

## 输入格式

输入矩阵的规模，不超过 $9$。

## 输出格式

输出矩形和正方形

## 样例 #1

### 样例输入 #1

```
4
```

### 样例输出 #1

```
01020304
05060708
09101112
13141516

      01
    0203
  040506
07080910
```",循环结构,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int n = sc.nextInt();
                int n1 = 0;
                int c = 1;
                for(int i = 1; i<= n*n;i++){
                        System.out.printf(""%02d"",i);
                        if(i%n == 0)
                                System.out.println();
                }
                System.out.println();
                for(int i = 1;i<=n;i++){
                        for(int a = 1;a<=(n-i)*2;a++)
                                System.out.printf("" "");
                        for(int b = 1;b<=i;b++){
                                System.out.printf(""%02d"",c);
                                n1++;c++;
                                if(n1 == i) {
                                        System.out.println();
                                        n1 = 0;
                                }
 
                        }
                }
        }
}",0
,"# 打分

## 题目描述

现在有 $n(n \le 1000)$ 位评委给选手打分，分值从 $0$ 到 $10$。需要去掉一个最高分，去掉一个最低分（如果有多个最高或者最低分，也只需要去掉一个），剩下的评分的平均数就是这位选手的得分。现在输入评委人数和他们的打分，请输出选手的最后得分，精确到 $2$ 位小数。

## 输入格式

第一行输入一个正整数 $n$，表示有 $n$ 个评委。

第二行输入 $n$ 个正整数，第 $i$ 个正整数表示第 $i$ 个评委打出的分值。

## 输出格式

输出一行一个两位小数，表示选手的最后得分。

## 样例 #1

### 样例输入 #1

```
5
9 5 6 8 9
```

### 样例输出 #1

```
7.67
```

## 提示

数据保证，$3 \leq n \leq 1000$，每个评委打出的分值为为 $0$ 到 $10$（含 $0$ 与 $10$）之间的整数。",循环结构,,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int n = sc.nextInt();
                int max = 0,min = 10;
                int sum = 0;
                for(int i = 0;i<n;i++){
                        int a = sc.nextInt();
                        sum+=a;
                        if(a<min)
                                min = a;
                        if(a>max)
                                max = a;
                }
                sum = sum - min - max;
                double n1 = n-2;
                double avg = sum/n1;
                System.out.printf(""%.2f"",avg);
        }
}",1
,"# 津津的储蓄计划

## 题目描述

津津的零花钱一直都是自己管理。每个月的月初妈妈给津津 $300$ 元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。

为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上 $20\%$ 还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于 $100$ 元或恰好 $100$ 元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。


例如 $11$月初津津手中还有 $83$ 元，妈妈给了津津 $300$ 元。津津预计$11$月的花销是 $180$ 元，那么她就会在妈妈那里存 $200$ 元，自己留下 $183$ 元。到了 $11$ 月月末，津津手中会剩下 $3$ 元钱。


津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。


现在请你根据 $2004$ 年 $1$ 月到 $12$ 月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到 $2004$ 年年末，妈妈将津津平常存的钱加上 $20\%$ 还给津津之后，津津手中会有多少钱。

## 输入格式

$12$ 行数据，每行包含一个小于 $350$ 的非负整数，分别表示 $1$ 月到 $12$ 月津津的预算。

## 输出格式

一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出 $-X$，$X$ 表示出现这种情况的第一个月；否则输出到 $2004$ 年年末津津手中会有多少钱。

注意，洛谷不需要进行文件输入输出，而是标准输入输出。

## 样例 #1

### 样例输入 #1

```
290
230
280
200
300
170
340
50 
90 
80 
200
60
```

### 样例输出 #1

```
-7
```

## 样例 #2

### 样例输入 #2

```
290 
230 
280 
200 
300 
170 
330 
50 
90 
80 
200 
60
```

### 样例输出 #2

```
1580
```","循环结构,模拟,枚举",,,,,"import java.util.Scanner;
 
public class Main {
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int b = 0;
                int sum = 0;//结余
                int save = 0;
                int m = 0;
                boolean d = true;//钱是否够用
                for(int i = 1;i<=12;i++){
                        int a = sc.nextInt();
                        b = 300 + sum - a;
                        if(b/100>=0){
                                save += b/100;//存入整百的个数
                                sum = b - b/100*100;//目前结余减去整百的金额
                        }
                        if(b<0) {
                                m = i;
                                System.out.println(""-"" + m);
                                d = false;
                                break;
                        }
                }
                if(d){
                        int e = (int) (sum+save*100*1.2);
                        System.out.printf(""%d"",e);
                }
        }
}",0
